<?php

/**
 * XBRL Formulas
 *  _					   _	 _ _ _
 * | |   _   _  __ _ _   _(_) __| (_) |_ _   _
 * | |  | | | |/ _` | | | | |/ _` | | __| | | |
 * | |__| |_| | (_| | |_| | | (_| | | |_| |_| |
 * |_____\__, |\__, |\__,_|_|\__,_|_|\__|\__, |
 *	     |___/	  |_|					 |___/
 *
 * @author Bill Seddon
 * @version 0.9
 * @Copyright ( C ) 2017 Lyquidity Solutions Limited
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * ( at your option ) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

namespace XBRL\Formulas\Resources\Formulas;

use lyquidity\XPath2\TreeComparer;
use lyquidity\XPath2\DOM\DOMXPathNavigator;
use lyquidity\xml\MS\XmlNamespaceManager;
use lyquidity\xml\xpath\XPathNodeType;
use XBRL\Formulas\ContextComparer;
use lyquidity\XPath2\Iterator\AttributeNodeIterator;
use lyquidity\XPath2\XPath2NodeIterator;
use XBRL\Formulas\FactValues;
use lyquidity\xml\QName;

/**
 * A container class for the facts generated by the evaluation of a formula
 * By separating the facts into a container they can be passed from formula
 * to formula so the facts can accumulate before they are used to generate
 * an instance document (or something)
 */
class GeneratedFacts
{
	/**
	 * A list of generate facts
	 * @var array $facts
	 */
	public $facts = array();

	/**
	 * A list of contexts created for the facts
	 * @var array $contexts
	 */
	public $contexts = array();

	/**
	 * A list of hashes and their context references
	 * @var array $contextHashes
	 */
	public $contextHashes = array();

	/**
	 * A list of context refs and the highest index used
	 * @var array $contextRefIndexes
	 */
	public $contextRefIndexes = array();

	/**
	 * A list of units created for the facts
	 * @var array $units
	 */
	public $units = array();

	/**
	 * A list of hashes and their unit references
	 * @var array $unitHashes
	 */
	public $unitHashes = array();

	/**
	 * A list of unit refs and the highest index used
	 * @var array $contextRefIndexes
	 */
	public $unitRefIndexes = array();

	/**
	 * A list of linkbases to add to the generated document
	 * @var array $linkbases
	 */
	public $linkbases = array();

	/**
	 * Used to return a message about the reason for a comparison failure
	 * @var string $comparisonError
	 */
	public $comparisonError = null;

	/**
	 * A list of fact for a variable set indexed by the same offset as the one used in $facts
	 * @var array $vars
	 */
	public $vars = array();

	/**
	 * A list of sources for a variable set indexed by the same offset as the one used in $facts
	 * @var array $sources
	 */
	public $sources = array();

	/**
	 * A list of namespaces that applies to this instance
	 * @var array
	 */
	public $namespaces = array();

	/**
	 * Generate an XML instance document
	 * @param \XBRL_Instance $xbrlInstance The source instance from which the facts have been generated
	 * @param XmlNamespaceManager $nsMgr
	 * @return string
	 */
	public function generateInstanceDocument( $xbrlInstance, $nsMgr )
	{
		// Get the namespaces from the input documment
		// $namespaces = $xbrlInstance->getInstanceXml()->getDocNamespaces();

		// Get the taxonomy document uri from the input document
		$taxonomyUri = $xbrlInstance->getInstanceTaxonomy()->getTaxonomyXSD();

		$document[] = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
		$document[] = "<!-- Generated by XBRLQuery formula processor -->";

		// Add the root element and namespaces
		// First make sure there is a default xbrli prefix
		if ( ! isset( $this->namespaces[''] ) )
		{
			$this->namespaces[''] = \XBRL_Constants::$standardPrefixes[ STANDARD_PREFIX_XBRLI ];
		}
		$document[] ="<xbrl";
		foreach ( $this->namespaces as $prefix => $namespace )
		{
			$document[] = "  " . ( $prefix ? "xmlns:$prefix=\"$namespace\"" : "xmlns=\"$namespace\"" );
		}

		if ( ! isset( $this->namespaces['xsi'] ) &&
				array_filter( $this->facts, function( $facts ) {
					return array_filter( $facts, function( $fact ) { return is_null( $fact['value'] ); } ); }
				)
		   )
		{
			$document[] = "  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"";
		}

		if ( ! isset( $this->namespaces['link'] ) )
		{
			$document[] = "  xmlns:link=\"http://www.xbrl.org/2003/linkbase\"";
		}

		$document[] =">";

		// Add the schema ref
		$document[] = "";
		$document[] = "  <link:schemaRef  xlink:type=\"simple\" xlink:href=\"$taxonomyUri\"/>";
		$document[] = "";

		foreach ( $this->linkbases as $linkbase )
		{
			$document[] = "  <link:linkbaseRef";
			$document[] = "    xlink:type=\"{$linkbase['xlink:type']}\"";
			$document[] = "    xlink:arcrole=\"{$linkbase['xlink:arcrole']}\"";
			$document[] = "    xlink:href=\"{$linkbase['xlink:href']}\"";
			$document[] = "  />";
			$document[] = "";
		}

		// Add the contexts
		// $this->addContexts( $document, $xbrlInstance->getPrefixForNamespace( \XBRL_Constants::$standardPrefixes[ STANDARD_PREFIX_XBRLDI ] ) );
		$this->addContexts( $document, STANDARD_PREFIX_XBRLDI );

		// Add the units
		$this->addUnits( $document );

		// Add the facts
		$this->addFacts2( $document );

		// Close the document
		$document[] ="</xbrl>";

		// Run validation on the generated document

		return implode( "\n", $document) ;
	}

	/**
	 * Returns true if there is an instance comparison file
	 * @param \SimpleXMLElement $expectedResultNode
	 */
	public function hasInstanceFile( $expectedResultNode )
	{
		return property_exists( $expectedResultNode, "instance" ) && (string)$expectedResultNode->instance;
	}

	/**
	 * Allows the class to compare the expected result node to the result created
	 * Returns false if there is no problem or an error string to report if there is.
	 * @param string $testCaseFolder
	 * @param \SimpleXMLElement $expectedResultNode	The content of the <result> node from the test case.
	 * 												The relevant test class will know how to handle its content.
	 * @param \XBRL_Instance $xbrlInstance The source instance from which the facts have been generated
	 * @return bool|string False if there is no error or a string that describes the failure
	 */
	public function compareResult( $testCaseFolder, $expectedResultNode, $xbrlInstance )
	{
		// The $expectedResultNode should contain a single element 'instance' that contains the name of the expected instance file
		if ( ! $this->hasInstanceFile( $expectedResultNode ) )
		{
			$this->comparisonError = "A comparison file name has not been provided";
			return false;
		}

		$expectedResultFile = urldecode( "$testCaseFolder/{$expectedResultNode->instance}" );
		if ( ! file_exists( $expectedResultFile ) )
		{
			$this->comparisonError = "The instance file cannot be found: $expectedResultFile";
			return false;
		}

		/**
		 * @var \DOMDocument $expectedDoc
		 */
		$expectedDoc = new \DOMDocument();
		if ( $expectedDoc->load( $expectedResultFile ) === false )
		{
			$this->comparisonError = "Failed to read instance xml file";
			return false;
		}

		// Look for any linkbaseRef elements
		$expectedNav = new DOMXPathNavigator( $expectedDoc );
		$result = $expectedNav->MoveToDocumentElement();
		$result = $expectedNav->MoveToChild( XPathNodeType::Element );
		while( $result )
		{
			if ( $expectedNav->getLocalName() == "linkbaseRef" )
			{
				$attribute = $expectedNav->CloneInstance();
				$attrResult = $attribute->MoveToFirstAttribute();
				$linkbase = array();
				while ( $attrResult )
				{
					$linkbase[ $attribute->getName() ] = (string)$attribute->getValue();
					$attrResult = $attribute->MoveToNext( XPathNodeType::Attribute );
				}
				$this->linkbases[] = $linkbase;
			}

			// Link role references appear before contexts or concepts
			else if ( $expectedNav->getLocalName() == "context" )
			{
				break;
			}

			$result = $expectedNav->MoveToNext( XPathNodeType::Element );
		}

		$expectedNav->MoveToRoot();

		try
		{
			$generatedXml = $this->generateInstanceDocument( $xbrlInstance, null );
			global $debug_statements;
			if ( $debug_statements )
			{
				echo $generatedXml . "\n";
			}

			/**
			 * @var \DOMDocument $doc2
			 */
			$generatedDoc = new \DOMDocument();
			if ( @$generatedDoc->loadXML( $generatedXml ) === false )
			{
				$this->comparisonError = "The generated instance xml file failed to load";
				return false;
			}

			$generatedNav = new DOMXPathNavigator( $generatedDoc );

			// Wouldn't it be nice to simply iterate over concepts but the concepts can be in any order relative
			// to each other.  So its necessary to get a list of the concepts, contexts and unit for each document
			// being compared.  The units and contexts can be matched by content and the names of the matched
			// components put into a dictionary so two matching contexts or unit can be used.
			// Then each generated fact can be compared with each expected fact until a match is found.
			// The facts are put into an array indexed by concept name, context ref and unit ref.  This way, the
			// number of expected facts a generated fact must be compared with is minimized.

			// The main things to compare are the generated concepts so get the navigators to the first of them
			$expectedContexts = array();
			$expectedUnits = array();
			$generatedContexts = array();
			$generatedUnits = array();

			$result1 = $this->moveToFirstConcept( $expectedNav, $expectedContexts, $expectedUnits );
			$result2 = $this->moveToFirstConcept( $generatedNav, $generatedContexts, $generatedUnits );

			if ( $result1 != $result2 )
			{
				$this->comparisonError = $result1
					? "The expected results document contains concepts while the generated document does not"
					: "The generated results document contains concepts while the expected results document does not";
				return false;
			}

			if ( ! $result1 )
			{
				return true;
			}

			// Normalize (match up) expected and generated contexts and return a map array
			// NOTE: The XML instance document is being used (not $xbrlInstance) because
			// there is no XBRL_Instance of the generated document
			$contextsMap = $this->normalizeComponents( $expectedContexts, $generatedContexts );
			$unitsMap = $this->normalizeComponents( $expectedUnits, $generatedUnits );

			// Now create an indexed list of all the expected concepts
			$expectedConcepts = $this->indexConcepts( $expectedNav, $xbrlInstance );
			$generatedConcepts = $this->indexConcepts( $generatedNav, $xbrlInstance );

			$expectedConceptsCount = count( $expectedConcepts );
			$generatedConceptsCount = count( $generatedConcepts );

			if ( count( $expectedConcepts ) != count( $generatedConcepts ) )
			{
				$this->comparisonError = "The number of expected concepts ($expectedConceptsCount) does not match the number of generated concepts ($generatedConceptsCount)";
				return false;
			}

			if (  count( $expectedConcepts ) == 0 )
			{
				return true;
			}

			// Now loop over the concepts checking matched entries
			foreach ( $expectedConcepts as $expectedConceptName => $expectedContextRefs )
			{
				foreach ( $expectedContextRefs as $expectedContextName => $expectedUnitRefs )
				{
					foreach ( $expectedUnitRefs as $expectedUnitName => /** @var array[DOMXPathNavigator] $expectedConceptNavs */ $expectedConceptNavLines )
					{
						foreach ( $expectedConceptNavLines as $expectedLineNo => /** @var DOMXPathNavigator $expectedConceptNav */$expectedConceptNavs )
						{
							foreach ( $expectedConceptNavs as $expectedIndex => $expectedConceptNav )
							{
								// Get the value so the concepts can be matched on value
								$expectedConceptNavIsTuple = FactValues::isTuple( $expectedConceptNav );
								$expectedValue = $expectedConceptNavIsTuple ? "" : trim( $expectedConceptNav->getValue() );

								// Look for the corresponding generated concept.  Take into account the context and unit maps.
								if ( $expectedContextName && ! isset( $contextsMap[ $expectedContextName ]) )
								{
									$this->comparisonError = "The context ($expectedContextName) cannot be located in the generated context map";
									return false;
								}

								$mappedContextRef = $expectedContextName ? $contextsMap[ $expectedContextName ] : null;

								if ( $expectedUnitName && count( $unitsMap ) && ! isset( $unitsMap[ $expectedUnitName ]) )
								{
									$this->comparisonError = "The context ($expectedUnitName) cannot be located in the generated unit map";
									return false;
								}

								$mappedUnitRef = $expectedUnitName && count( $unitsMap ) ? $unitsMap[ $expectedUnitName ] : "";
								if ( ! isset( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ] ) )
								{
									$this->comparisonError = "The concept ($expectedConceptName) at line {$expectedNav->getLineNo()} cannot be located among the generated concepts";
									return false;
								}

								$generatedConceptNavLines = $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ];
								// If the same line number exists try it first.  This can be negative if the line does not exist or if there is only one line anyway
								$singleLine = isset( $generatedConceptNavLines[ $expectedLineNo ] ) && count( $generatedConceptNavLines[ $expectedLineNo ] ) > 1;
								while ( true )
								{
									$matched = false;
									foreach ( $singleLine
											? array( $expectedLineNo => $generatedConceptNavLines[ $expectedLineNo ] )
											: $generatedConceptNavLines as $generatedLineNo => $generatedConceptNavs )
									{
										// Already done the same line number
										if ( ! $singleLine &&
											 isset( $generatedConceptNavLines[ $expectedLineNo ] ) &&
											 count( $generatedConceptNavLines[ $expectedLineNo ] ) > 1 &&
											 $generatedLineNo == $expectedLineNo ) continue;

										foreach ( $generatedConceptNavs as $generatedIndex => $generatedConceptNav )
										{
											// Get the value so the concepts can be matched on value
											$generatedNavIsTuple = FactValues::isTuple( $generatedConceptNav );
											$generatedValue = $generatedNavIsTuple ? "" : trim( $generatedConceptNav->getValue() );

											// A blatent mismatch
											if ( $expectedConceptNavIsTuple != $generatedNavIsTuple || $generatedValue != $expectedValue ) continue;

											if ( $this->compareConcepts(
													$expectedConceptNav,
													$generatedConceptNav,
													$expectedContexts,
													$generatedContexts,
													$expectedUnits,
													$generatedUnits,
													$expectedConceptNavIsTuple,
													$generatedNavIsTuple

												)
											)
											{
												unset( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ][ $generatedLineNo ][ $generatedIndex ] );

												// The following lines are to tidy up - it helps with debugging
												if ( ! count( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ][ $generatedLineNo ] ) )
												{
													unset( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ][ $generatedLineNo ] );
													if ( ! count( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ] ) )
													{
														unset( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ][ $mappedUnitRef ] );

														if ( ! count( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ] ) )
														{
															unset( $generatedConcepts[ $expectedConceptName ][ $mappedContextRef ] );
															if ( ! count( $generatedConcepts[ $expectedConceptName ] ) )
															{
																unset( $generatedConcepts[ $expectedConceptName ] );
															}
														}
													}
												}

												$matched = true;
												break 3;
											}
										}
									}

									if ( $singleLine )
									{
										$singleLine = false;
										continue;
									}

									if ( ! $matched )
									{
										if ( ! $this->comparisonError )
										{
											$this->comparisonError = "No matching values";
										}
										return false;
									}
								}
							}
						}
					}
				}
			}

		}
		catch( \Exception $ex )
		{
			$this->comparisonError = $ex->getMessage();
			return false;
		}

		return true;
	}

	/**
	 * Creates an indexed array of concepts.  The index is concept|contextRef|unitRef => nav
	 * The unit maybe empty if there is no unit
	 * @param DOMXPathNavigator $nav
	 * @param \XBRL_Instance $xbrlInstance
	 * @param array $index (by reference) A list of concepts
	 * @param string $path (by reference)
	 * @return array A list of concepts
	 */
	private function indexConcepts( $nav, $xbrlInstance, &$index = array(), $path = "" )
	{
		// $index = array();
		$flag = true;
		$first = $nav->getLineNo();
		$taxonomy = $xbrlInstance->getInstanceTaxonomy();

		do
		{
			$name = "{$nav->getNamespaceURI()}:{$nav->getLocalName()}";
			if ( $path ) $name = "$path,$name";
			$num = $nav->getLineNo() - $first + 1;
			if ( FactValues::isTuple( $nav ) )
			{
				$index[ $name ][ null ][ null ][ $num ][] = $nav->CloneInstance();
				$childNav = $nav->CloneInstance();
				if ( $childNav->MoveToChild( XPathNodeType::Element ) )
				{
					$result = $this->indexConcepts( $childNav, $xbrlInstance, $index, $name );
					// $index = array_merge_recursive( $index, $result );
				}
			}
			else
			{
				$contextRef = $nav->GetAttribute( "contextRef", null );
				$unitRef = $nav->GetAttribute( "unitRef", null );

				$index[ $name ][ $contextRef ][ $unitRef ][ $num ][] = $nav->CloneInstance();
			}
			$flag = $nav->MoveToNext( XPathNodeType::Element );
		}
		while ( $flag );

		return $index;
	}

	/**
	 * Match up the components (contexts or units) and generate a map of the expected
	 * component name to the corresponding generated component name
	 * @param mixed $expected
	 * @param mixed $generated
	 */
	private function normalizeComponents( $expected, $generated )
	{
		$map = array();

		// BMS 2018-02-16 This does not work because they may be mismatched names.  For example in 47200 V-01
		// the expected contexts are 'context-1' .. 'context-9'.  However the generated contexts are 'context',
		// 'context-1' .. 'context-8' so they match by name but incorrectly.
		// First look for the components with matching names as this will be quickest and easiet. Ideally all will be matched this way
		// foreach ( $expected as $expectedName => $expectedComponent )
		// {
		// 	if ( ! isset( $generated[ $expectedName ] ) ) continue;
        //
		// 	$map[ $expectedName ] = $expectedName;
		// 	unset( $expected[ $expectedName] );
		// 	unset( $generated[ $expectedName ] );
		// }

		if ( is_null( $this->comparer ) )
		{
			$this->comparer = new ContextComparer( null );
			$this->comparer->excludeWhitespace = true;
		}

		// Now match up based on whether the component contents match
		foreach ( $expected as $expectedName => $expectedNav )
		{
			foreach ( $generated as $generatedName => $generatedNav )
			{
				if ( ! $this->comparer->DeepEqualByNavigator( $expectedNav, $generatedNav ) ) continue;

				$map[ $expectedName ] = $generatedName;
				unset( $expected[ $expectedName] );
				unset( $generated[ $generatedName ] );

				break;
			}
		}

		return $map;
	}

	/**
	 * Compare each concept.  The name of the concept ref and of the unit refs may be different but the content should be OK
	 * @param DOMXPathNavigator $expectedNav
	 * @param DOMXPathNavigator $generatedNav
	 * @param array[DOMXPathNavigator] $expectedContexts
	 * @param array[DOMXPathNavigator] $generatedContexts
	 * @param array[DOMXPathNavigator] $expectedUnits
	 * @param array[DOMXPathNavigator] $generatedUnits
	 * @param bool $expectedConceptNavIsTuple
	 * @param bool $generatedNavIsTuple
	 * @return bool
	 */
	private function compareConcepts( $expectedNav, $generatedNav, $expectedContexts, $generatedContexts, $expectedUnits, $generatedUnits, $expectedConceptNavIsTuple, $generatedNavIsTuple )
	{
		// Compare the names
		if ( $expectedNav->getLocalName() != $generatedNav->getLocalName() ||
			 $expectedNav->getNamespaceURI() != $generatedNav->getNamespaceURI() )
		{
			$this->comparisonError = "The concept names and/or namespaces do not match for concept line numbers {$expectedNav->getLineNo()} and {$generatedNav->getLineNo()}";
			return false;
		}

		if ( $expectedConceptNavIsTuple != $generatedNavIsTuple )
		{
			return false;
		}

		if ( $expectedConceptNavIsTuple )
		{
			return true;
		}

		// Make sure the elements have the same parent
		$expectedNavParent = $expectedNav->CloneInstance();
		$generatedNavParent = $generatedNav->CloneInstance();

		$expectedNavHasParent = $expectedNavParent->MoveToParent();
		$generatedNavHasParent = $generatedNavParent->MoveToParent();

		if (  $expectedNavHasParent != $generatedNavHasParent )
		{
			return false;
		}

		if ( $expectedNavParent->getLocalName() != $generatedNavParent->getLocalName() || $expectedNavParent->getNamespaceURI() != $generatedNavParent->getNamespaceURI() )
		{
			return false;
		}

		// Compare the value if it is a simple value
		$expectedHasChildren = $expectedNav->CloneInstance()->MoveToChild( XPathNodeType::Element );
		$generatedHasChildren = $generatedNav->CloneInstance()->MoveToChild( XPathNodeType::Element );

		if ( $expectedHasChildren != $generatedHasChildren )
		{
			$this->comparisonError = "There is a mis-match between the number of nested elements in expected concept {$expectedNav->getLineNo()} ({$expectedNav->getName()})";
			return false;
		}

		if ( ! $generatedHasChildren )
		{
			$expectedValue = trim( $expectedNav->getValue() );
			$generatedValue = trim( $generatedNav->getValue() );
			if ( $expectedValue != $generatedValue )
			{
				$this->comparisonError = "The values in expected concept {$expectedNav->getLineNo()} ({$expectedNav->getName()}) do not match";
				return false;
			}
		}

		// Compare the attributes
		if ( ! $this->compareAttributes( $expectedNav, $generatedNav, $expectedContexts, $generatedContexts, $expectedUnits, $generatedUnits ) )
		{
			// Any error will be reported by the sub-function
			return false;
		}

		// BMS 2018-03-18 Don't want to do this because the child elements may be in a different order but still equivalent (just not exactly the same).
		// // Compare any nested elements (tuples)
		// if ( $generatedHasChildren )
		// {
		// 	$expectedChildNav = $expectedNav->CloneInstance();
		// 	$result1 = $expectedChildNav->MoveToChild( XPathNodeType::Element );
        //
		// 	$generatedChildNav = $expectedNav->CloneInstance();
		// 	$result2 = $generatedChildNav->MoveToChild( XPathNodeType::Element );
        //
		// 	do
		// 	{
		// 		if ( ! $this->compareConcepts(
		// 				$expectedChildNav,
		// 				$generatedChildNav,
		// 				$expectedContexts,
		// 				$generatedContexts,
		// 				$expectedUnits,
		// 				$generatedUnits
		// 			)
		// 		)
		// 		{
		// 			// Any error will be reported by the sub-function
		// 			return false;
		// 		}
        //
		// 		$result1 = $expectedChildNav->MoveToNext( XPathNodeType::Element );
		// 		$result2 = $generatedChildNav->MoveToNext( XPathNodeType::Element );
		// 	}
		// 	while( $result1 && $result2 );
        //
		// }

		return true;
	}

	/**
	 * Compare the attributes of the two navigators provided
	 * @param DOMXPathNavigator $expectedNav
	 * @param DOMXPathNavigator $generatedNav
	 * @param array[DOMXPathNavigator] $expectedContexts
	 * @param array[DOMXPathNavigator] $generatedContexts
	 * @param array[DOMXPathNavigator] $expectedUnits
	 * @param array[DOMXPathNavigator] $generatedUnits
	 * @return bool
	 */
	private function compareAttributes( $expectedNav, $generatedNav, $expectedContexts, $generatedContexts, $expectedUnits, $generatedUnits )
	{
		// Gather all the attribute (they may be in different orders and that does not matter
		$expectedAttributes = $this->getAttributes( $expectedNav );
		$generatedAttributes = $this->getAttributes( $generatedNav );

		// It's an error if the elements don't agree on whether there are the same number of attributes
		if ( count( $expectedAttributes ) != count( $generatedAttributes ) )
		{
			$this->comparisonError = "There is a difference in the number of attributes in expected concept {$expectedNav->getLineNo()} ({count($expectedAttributes)} vs {count($generatedAttributes)})";
			return false;
		}

		// Only check attributes if there are any (tuples will not have attributes)
		if ( ! count( $expectedAttributes ) )
		{
			return true;
		}

		foreach ( $expectedAttributes as $name => $value )
		{
			// There should be an element of the same name in the other array
			// Change to omit the decimals and precision attributes
			if ( ! in_array( $name, array( 'decimals', 'precision' ) ) && ! isset( $generatedAttributes[ $name ] ) )
			{
				$this->comparisonError = "There should be an attribute called '$name' in generated concept {$generatedNav->getLineNo()}";
				return false;
			}

			switch ( $name )
			{
				case 'contextRef':

					if ( $value != $generatedAttributes[ $name ] )
					{
						if ( ! $this->compareNodes( $expectedContexts[ $value ]->CloneInstance(), $generatedContexts[ $generatedAttributes[ $name ] ]->CloneInstance() ) )
						{
							$this->comparisonError = "Contexts comparison for expected concept {$expectedNav->getLineNo()} failed";
							return false;
						}
					}

					break;

				case 'unitRef':

					if ( $value != $generatedAttributes[ $name ] )
					{
						if ( ! $this->compareNodes( $expectedUnits[ $value ]->CloneInstance(), $generatedUnits[ $generatedAttributes[ $name ] ]->CloneInstance() ) )
						{
							$this->comparisonError = "Units comparison for expected concept {$expectedNav->getLineNo()} failed";
							return false;
						}
					}

					break;

				case 'decimals':

					// Match the decimals attribute
					if ( isset( $generatedAttributes[ $name ] ) )
					{
						goto defaultTest;
					}
					else
					{
						// Need to compare a decimal with a precision
						$inferredDecimals = \XBRL_Instance::inferDecimals( $generatedNav->getValue(), $generatedAttributes[ 'precision' ] );
						if ( $inferredDecimals === false ) $inferredDecimals = 0;
						if ( $value != $inferredDecimals )
						{
							$this->comparisonError = "Attribute comparison '$name' for expected concept {$expectedNav->getLineNo()} failed ({$value} vs {$generatedAttributes[ $name ]})";
						}
					}

					break;

				case 'precision':

					// Match the precision attribute
					if ( isset( $generatedAttributes[ $name ] ) )
					{
						goto defaultTest;
					}
					else
					{
						$inferredPrecision = \XBRL_Instance::inferPrecision( $generatedNav->getValue(), $generatedAttributes['decimals'] );
						if ( $value != $inferredPrecision )
						{
							$this->comparisonError = "Attribute comparison '$name' for expected concept {$expectedNav->getLineNo()} failed ({$value} vs {$generatedAttributes[ $name ]})";
						}
					}

					break;

				default:

					defaultTest: // This is a target for the default precision and decimals texts
					if ( $value != $generatedAttributes[ $name ] )
					{
						$this->comparisonError = "Attribute comparison for '$name' expected concept {$expectedNav->getLineNo()} failed ({$value} vs {$generatedAttributes[ $name ]})";
						return false;
					}

					break;
			}
		}

		return true;
	}

	/**
	 * A holder for a TreeComparer
	 * @var TreeComparer $comparer
	 */
	private $comparer = null;

	/**
	 * Compare two nodes for equality
	 * @param DOMXPathNavigator $expectedNav
	 * @param DOMXPathNavigator $generatedNav
	 */
	private function compareNodes( $expectedNav, $generatedNav )
	{
		if ( is_null( $this->comparer ) )
		{
			// $this->comparer = new TreeComparer( null );
			$this->comparer = new ContextComparer( null );
			$this->comparer->excludeWhitespace = true;
		}

		return $this->comparer->DeepEqualByNavigator( $expectedNav , $generatedNav );
	}

	/**
	 * Return an array of the attribute values for $nav
	 * @param DOMXPathNavigator $nav
	 * return array
	 */
	private function getAttributes( $nav )
	{
		$result = array();

		$attrNav = $nav->CloneInstance();
		$flag = $attrNav->MoveToFirstAttribute();

		if ( $flag )
		{
			do
			{
				$result[ $attrNav->getName() ] = trim( $attrNav->getValue() );
				$flag = $attrNav->MoveToNext( XPathNodeType::Attribute );
			}
			while ( $flag );
		}

		return $result;
	}

	/**
	 * Move the navigator to the first concept in the document processng all elements along the way
	 * @param DOMXPathNavigator $nav
	 * @param array $contexts (by reference)
	 * @param array $units (by reference)
	 */
	private function moveToFirstConcept( $nav, &$contexts, &$units )
	{
		$nav->MoveToDocumentElement();

		$result = $nav->MoveToChild( XPathNodeType::Element );
		while ( $result )
		{
			switch ( $nav->getLocalName() )
			{
				case 'schemaRef':
					break;

				case 'linkbaseRef':
					break;

				case 'context':
					$id = $nav->GetAttribute( 'id', null );
					$contexts[ $id ] = $nav->CloneInstance();
					break;

				case 'unit':
					$id = $nav->GetAttribute( 'id', null );
					$units[ $id ] = $nav->CloneInstance();
					break;

				default:
					// Don't be tempted to chgange this
					return true;
			}

			$result = $nav->MoveToNext( XPathNodeType::Element );
		}

		return false;
	}

	/**
	 * An array to which context information should be added
	 * @param array $document (passed by reference)
	 * @param string $xbrldiPrefix
	 */
	private function addContexts( &$document, $xbrldiPrefix )
	{
		foreach ( $this->contexts as $contextRef => $context )
		{
			$document[] = "  <context id=\"$contextRef\">";

			if ( isset( $context['entity'] ) )
			{
				$document[] = "    <entity>";

				if ( isset( $context['entity']['identifier'] ) )
				{
					$document[] = "      <identifier scheme=\"{$context['entity']['identifier']['scheme']}\">{$context['entity']['identifier']['value']}</identifier>";
				}

				if ( isset( $context['entity']['segment'] ) )
				{
					$this->addComponent( "segment", $context['entity']['segment'], $document, "      ", $xbrldiPrefix );
				}

				if ( isset( $context['entity']['scenario'] ) )
				{
					$this->addComponent( "scenario", $context['entity']['scenario'], $document, "    ", $xbrldiPrefix );
				}

				$document[] = "    </entity>";
			}

			if ( isset( $context['period'] ) )
			{
				$document[] = "    <period>";

				if ( $context['period']['is_instant'] )
				{
					$document[] = "      <instant>{$context['period']['startDate']}</instant>";
				}
				else if ( isset( $context['period']['type'] ) && $context['period']['type'] == 'forever' )
				{
					$document[] = "      <forever/>";
				}
				else if ( isset( $context['period']['type'] ) && $context['period']['type'] == 'duration' )
				{
					$document[] = "      <startDate>{$context['period']['startDate']}</startDate>";
					$document[] = "      <endDate>{$context['period']['endDate']}</endDate>";
				}
				$document[] = "    </period>";
			}

			if ( isset( $context['segment'] ) )
			{
				$this->addComponent( "segment", $context['segment'], $document, "    ", $xbrldiPrefix );
			}

			if ( isset( $context['scenario'] ) )
			{
				$this->addComponent( "scenario", $context['scenario'], $document, "  ", $xbrldiPrefix );
			}

			$document[] = "  </context>";
			$document[] = "";
		}
	}

	/**
	 * Add the details for an OCC
	 * @param string $componentType Scenario or segment
	 * @param array $component A list of componets for the component type
	 * @param array $document An array of lines
	 * @param string $prefix The text (spaces) to add as a prefix to the line
	 * @param string $xbrldiPrefix The xbrldi prefix to use in this generated document
	 */
	private function addComponent( $componentType, $component, &$document, $prefix, $xbrldiPrefix )
	{
		$entry[] = "<$componentType>";

		foreach ( $component as $memberType => $members )
		{
			switch ( $memberType )
			{
				case 'member':

					// $entry[] = "  <member>";

					foreach ( $members as $member )
					{
						$attributesList = array();
						$attributes = "";

						if ( isset( $member['attributes'] ) )
						{
							foreach ( $member['attributes'] as $name => $attribute )
							{
								$attributesList[] = "{$attribute['name']}=\"{$attribute['value']}\"";
							}

							$attributes = " " . implode( " ", $attributesList ) . " ";
						}

						if ( isset( $member['member'] ) )
						{
							if ( $member['member'] )
							{
								$entry[] = "  <{$member['name']}>{$member['member']}</{$member['name']}$attributes>";
							}
							else
							{
								$entry[] = "  <{$member['name']}$attributes/>";
							}
						}
						else if ( isset( $member['children'] ) )
						{
							$createXml = function( $member, $length, $attributes = null ) use( &$createXml, &$entry )
							{
								$padding = str_pad( "", $length, " ");

								if ( isset( $member['children'] ) )
								{
									$entry[] = $padding . "<{$member['prefix']}:{$member['name']}$attributes>";
									foreach ( $member['children'] as $child )
									{
										$createXml( $child, $length + 2 );
									}
									$entry[] = $padding . "</{$member['prefix']}:{$member['name']}>";
								}
								else
								{
									$entry[] = $padding. "<{$member['prefix']}:{$member['name']}$attributes/>";
								}
							};

							$createXml( $member, 2, $attributes);
						}
					}

					// $entry[] = "  </member>";

					break;

				case 'explicitMember':

					foreach ( $members as $member )
					{
						$entry[] = "  <$xbrldiPrefix:explicitMember dimension=\"{$member['dimension']}\">{$member['member']}</$xbrldiPrefix:explicitMember>";
					}

					break;

				case 'typedMember':

					foreach ( $members as $member )
					{
						$entry[] = "  <$xbrldiPrefix:typedMember dimension=\"{$member['dimension']}\">";
						foreach ( $member['member'] as $valueName => $names )
						{
							if ( is_array( $names ) )
							{
								foreach ( $names as $name )
								{
									// $entry[] = "    <$valueName>$name</$valueName>";
									$entry[] = "    $name";
								}
							}
							else
							{
								$entry[] = "    <$valueName>$names</$valueName>";
							}
						}
						$entry[] = "  </$xbrldiPrefix:typedMember>";
					}

					break;
			}
		}

		$entry[] = "</$componentType>";

		$document[] = $prefix . implode( "\n$prefix", $entry );
	}

	/**
	 * An array to which unit information should be added
	 * @param array $document (passed by reference)
	 */
	private function addUnits( &$document )
	{
		foreach ( $this->units as $unitRef => $unit )
		{
			$entry = array();
			$entry[] = "  <unit id=\"$unitRef\">";

			if ( isset( $unit['divide'] ) )
			{
				$entry[] = "    <divide>";

				if ( isset( $unit['divide']['numerator'] ) && count( $unit['divide']['numerator'] ) )
				{
					$entry[] = "      <unitNumerator>";

					foreach ( $unit['divide']['numerator'] as $measure )
					{
						$entry[] = "        <measure>$measure</measure>";
					}

					$entry[] = "      </unitNumerator>";
				}

				if ( isset( $unit['divide']['denominator'] ) && count( $unit['divide']['denominator'] ) )
				{
					$entry[] = "      <unitDenominator>";

					foreach ( $unit['divide']['denominator'] as $measure )
					{
						$entry[] = "        <measure>$measure</measure>";
					}

					$entry[] = "      </unitDenominator>";
				}

				$entry[] = "    </divide>";
			}
			else if ( isset( $unit['measures'] ) )
			{
				foreach ( $unit['measures'] as $measure )
				{
					$entry[] = "    <measure>$measure</measure>";
				}
			}
			else
			{
				$xbrli = STANDARD_PREFIX_XBRLI;
				$unit = str_replace( "{$xbrli}:", "", $unit );
				$entry[] = "    <measure>$unit</measure>";
			}
			$entry[] = "  </unit>";
			$entry[] = "";

			$document[] = implode( "\n", $entry );
		}
	}

	/**
	 * An array to which fact information should be added
	 * @param array $document (passed by reference)
	 */
	private function addFacts( &$document )
	{
		foreach ( $this->facts as $formulaFactKey => $formulaFacts )
		{
			foreach ( $formulaFacts as $factIndex => $fact )
			{
				/**
				 * @var QName $conceptQName
				 */
				$conceptQName = $fact['concept'];
				$concept = "{$conceptQName->prefix}:{$conceptQName->localName}";

				$entry = array();
				$entry[] = "<$concept ";

				if ( isset( $this->sources[ $formulaFactKey ] ) )
				{
					$attributesIterator = AttributeNodeIterator::fromNodeTest( null, null, XPath2NodeIterator::Create( $this->sources[ $formulaFactKey ] ) );
					$attributesIterator->Reset();
					$attributesIterator->MoveNext();
					foreach ( $attributesIterator as $attribute )
					{
						// Ignore the standard ones
						if ( empty( $attribute->getNamespaceURI() ) )
						{
							switch ( $attribute->getLocalName() )
							{
								case "contextRef":
								case "unitRef":
								case "decimals":
								case "precision":
									continue 2;

								default:
									break;
							}
						}
						else if ( $attribute->getNamespaceURI() == \XBRL_Constants::$standardNamespaces[ STANDARD_PREFIX_SCHEMA_INSTANCE ] )
						{
							if ( $attribute->getLocalName() == "nil" ) continue 2;
						}

						// Otherwise add an attribute
						$name = $attribute->getPrefix()
							? "{$attribute->getPrefix()}:{$attribute->getLocalName()}"
							: $attribute->getLocalName();
						$entry[] = "$name=\"{$attribute->getValue()}\"";
					}
				}

				// // Get the node if it exists
				// if ( isset( $this->vars[ $formulaFactKey ][ $factIndex ] ) )
				// {
				// 	foreach ( $this->vars[ $formulaFactKey ][ $factIndex ] as /* @var DOMXPathNavigator $var */ $var )
				// 	{
				// 		// $var will be a node iterator if the variable is bind as a sequence
				// 		if ( ! $var instanceof DOMXPathNavigator ) continue;
				// 		if ( $var->getNamespaceURI() != $fact['concept']->namespaceURI || $var->getLocalName() != $fact['concept']->localName )
				// 		{
				// 			continue;
				// 		}
                //
				// 		if ( ! $var instanceof DOMXPathNavigator || ! $var->getHasAttributes() ) continue;
				// 		// Test 46210 V-01 fails because an ID attribute should NOT be added
				// 		// Test 47212 V-01 fails because an ID attribute SHOULD be added.  What is the criteria?
				// 		if ( true )
				// 		{
				// 			$attributesIterator = AttributeNodeIterator::fromNodeTest( null, null, XPath2NodeIterator::Create( $var ) );
				// 			$attributesIterator->Reset();
				// 			foreach ( $attributesIterator as $attribute )
				// 			{
				// 				// Ignore the standard ones
				// 				if ( empty( $attribute->getNamespaceURI() ) )
				// 				{
				// 					switch ( $attribute->getLocalName() )
				// 					{
				// 						case "contextRef":
				// 						case "unitRef":
				// 						case "decimals":
				// 						case "precision":
				// 							continue 2;
                //
				// 						default:
				// 							break;
				// 					}
				// 				}
				// 				else if ( $attribute->getNamespaceURI() == \XBRL_Constants::$standardNamespaces[ STANDARD_PREFIX_SCHEMA_INSTANCE ] )
				// 				{
				// 					if ( $attribute->getLocalName() == "nil" ) continue 2;
				// 				}
                //
				// 				// Otherwise add an attribute
				// 				$name = $attribute->getPrefix()
				// 					? "{$attribute->getPrefix()}:{$attribute->getLocalName()}"
				// 					: $attribute->getLocalName();
				// 				$entry[] = "$name=\"{$attribute->getValue()}\"";
				// 			}
				// 		}
				// 	}
				// }

				$entry[] = "contextRef=\"{$fact['contextRef']}\"";

				if ( isset( $fact['unitRef'] ) )
				{
					$entry[] = "unitRef=\"{$fact['unitRef']}\"";
				}
				if ( isset( $fact['decimals'] ) )
				{
					$entry[] = "decimals=\"{$fact['decimals']}\"";
				}
				if ( isset( $fact['precision'] ) )
				{
					$entry[] = "precision=\"{$fact['precision']}\"";
				}

				if ( is_null( $fact['value'] ) )
				{
					$entry[] = "xsi:nil=\"true\"";
					$entry[] = "/>";
				}
				else
				{
					$value = htmlspecialchars( $fact['value'], ENT_XML1 | ENT_COMPAT, 'UTF-8' );
					$entry[] = ">$value</$concept>";
				}

				$document[] = "  " . implode( " ", $entry );
			}
		}
	}

	/**
	 * An array to which fact information should be added
	 * @param array $document (passed by reference)
	 */
	private function addFacts2( &$document )
	{
		$tuples = array();  // Collect a list of the defined tuples
		$entries = array(); // Collect a list of the non-tuple owned items
		$itemOrphans = array(); // If the tuple is defined after the item then the item will be orphaned and need to be processed again after the first pass

		// First process all the facts into an array so any tuples can can be identified and associate with relevant facts
		foreach ( $this->facts as $formulaFactKey => $formulaFacts )
		{
			foreach ( $formulaFacts as $factIndex => $fact )
			{
				/**
				 * @var QName $conceptQName
				 */
				$conceptQName = $fact['concept'];
				$concept = "{$conceptQName->prefix}:{$conceptQName->localName}";

				if ( $fact['isTuple'] )
				{
					$tuples[ $factIndex ] = array( 'concept' => $concept, 'entries' => array(), 'parentTupleGUID' => null );
					if ( isset( $fact['parentTupleGUID'] ) )
					{
						if ( isset( $tuples[ $fact['parentTupleGUID'] ] ) )
						{
							$tuples[ $factIndex ]['parentTupleGUID'] = $fact['parentTupleGUID'];
							// $tuples[ $fact['parentTupleGUID'] ]['entries'][ $factIndex ] = &$tuples[ $factIndex ];
						}
					}
					continue;
				}

				$entry = array();
				$entry[] = "<$concept ";

				if ( isset( $this->sources[ $formulaFactKey ] ) )
				{
					$attributesIterator = AttributeNodeIterator::fromNodeTest( null, null, XPath2NodeIterator::Create( $this->sources[ $formulaFactKey ] ) );
					$attributesIterator->Reset();
					$attributesIterator->MoveNext();
					foreach ( $attributesIterator as $attribute )
					{
						// Ignore the standard ones
						if ( empty( $attribute->getNamespaceURI() ) )
						{
							switch ( $attribute->getLocalName() )
							{
								case "contextRef":
								case "unitRef":
								case "decimals":
								case "precision":
									continue 2;

								default:
									break;
							}
						}
						else if ( $attribute->getNamespaceURI() == \XBRL_Constants::$standardPrefixes[ STANDARD_PREFIX_SCHEMA_INSTANCE ] )
						{
							if ( $attribute->getLocalName() == "nil" ) continue;
						}

						// Otherwise add an attribute
						$name = $attribute->getPrefix()
							? "{$attribute->getPrefix()}:{$attribute->getLocalName()}"
							: $attribute->getLocalName();
						$entry[] = "$name=\"{$attribute->getValue()}\"";
					}
				}

				$entry[] = "contextRef=\"{$fact['contextRef']}\"";

				if ( isset( $fact['unitRef'] ) )
				{
					$entry[] = "unitRef=\"{$fact['unitRef']}\"";
				}
				if ( isset( $fact['decimals'] ) )
				{
					$entry[] = "decimals=\"{$fact['decimals']}\"";
				}
				if ( isset( $fact['precision'] ) )
				{
					$entry[] = "precision=\"{$fact['precision']}\"";
				}

				if ( is_null( $fact['value'] ) )
				{
					$entry[] = "xsi:nil=\"true\"";
					$entry[] = "/>";
				}
				else
				{
					$value = htmlspecialchars( $fact['value'], ENT_XML1 | ENT_COMPAT, 'UTF-8' );
					$entry[] = ">$value</$concept>";
				}

				$element = implode( " ", $entry );

				if ( isset( $fact['parentTupleGUID'] ) )
				{
					if ( isset( $tuples[ $fact['parentTupleGUID'] ] ) )
					{
						$tuples[ $fact['parentTupleGUID'] ]['entries'][ $factIndex ] = $element;
					}
					else
					{
						$itemOrphans[ $factIndex ] = array( 'parentTupleGUID' => $fact['parentTupleGUID'], 'element' => $element );
					}
				}
				else
				{
					$entries[ $factIndex ] = "  " . $element;
				}

			}
		}

		$document[] = "  " . implode( "\n  ", $entries );

		foreach ( $itemOrphans as $orphanIndex => $orphan )
		{
			if ( isset( $tuples[ $fact['parentTupleGUID'] ] ) )
			{
				$tuples[ $orphan['parentTupleGUID'] ]['entries' ] = $orphan['element'];
			}
		}

		// This lambda function generates the tuple output potentially recursively
		$outputTuple = function( $tuple, $depth = 1 ) use( &$outputTuple, &$document )
		{
			$padding = str_repeat( " ", $depth * 2 );

			$document[] = "$padding<{$tuple['concept']} >";
			foreach ( $tuple['entries'] as $entryIndex => $entry )
			{
				if ( is_array( $entry ) )
				{
					$outputTuple( $entry, $depth + 1 );
				}
				else
				{
					$document[] = "$padding  $entry";
				}
			}
			$document[] = "$padding</{$tuple['concept']}>";
		};

		// Build the tuple hierarchy if there is one
		foreach ( $tuples as $tupleIndex => &$tuple )
		{
			if ( ! isset( $tuple['parentTupleGUID'] ) && $tuple['parentTupleGUID'] ) continue;
			if ( ! isset( $tuples[ $tuple['parentTupleGUID'] ] ) ) continue;

			$tuples[ $tuple['parentTupleGUID'] ]['entries'][ $tupleIndex ] =& $tuple;
			$tuple['assigned'] = true; // Flag the tuple as assigned to another tuples
			unset( $tuple );
		}
		unset( $tuple );

		// Remove the non-orphan tuples.  Use a second pass to do this so any out-of-order tuples are not removed to early above.
		foreach ( $tuples as $tupleIndex => $tuple )
		{
			if ( ! isset( $tuple['assigned'] ) ) continue;
			unset( $tuple['assigned'] );
			unset( $tuples[ $tupleIndex] );
		}

		// Generate the tuples
		foreach ( $tuples as $tupleIndex => $tuple )
		{
			$outputTuple( $tuple );
		}

	}

}