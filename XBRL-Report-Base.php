<?php

// @codingStandardsIgnoreStart
// @codingStandardsIgnoreEnd

/**
 * Reporting base class implementation
 *
 * @author Bill Seddon
 * @version 0.9
 * @Copyright (C) 2018 Lyquidity Solutions Limited
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

/**
 * Abstract class to support the creation of XBRL reports
 *
 */
abstract class XBRL_Report_Base
{
	/**
	 * A list of the currently loaded instance documents
	 * @var array $instanceDocuments
	 */
	private		$instanceDocuments = array();

	/**
	 * A map associated entity ids with an instance
	 * @var array $entityInstanceMap
	 */
	private		$entityInstanceMap = array();

	/**
	 * The schema file of the related taxonomy
	 * @var string $schemaFilename
	 */
	private		$schemaFilename = null;

	/**
	 * A reference to the taxonomy associated with the instance document(s)
	 * @var XBRL $taxonomy
	 */
	private		$taxonomy = null;

	/**
	 * A list of the reporting hierarches generated by the PreparePresenation function
	 * @var array $hierarchies
	 */
	private		$hierarchies = null;

	/**
	 * Flag for debugging
	 * @var boolean $debug
	 */
	private 	$debug = false;

	/**
	 * An array of the years in the contexts of the instance document(s) being reported
	 * @var array $years
	 */
	protected	$years = array();

	/**
	 * A flag to control whether
	 * @var boolean $includeDefaults
	 */
	protected	$includeDefaults = true;

	/**
	 * A list of the entities in the contexts of the instance document(s) being reported
	 * @var array $entities
	 */
	protected	$entities = array();

	/**
	 * A list of the years that are valid
	 * @var array
	 */
	protected	$validYears = array();

	/**
	 * The maximum depth of the deepest used node
	 * @var int $maxDepth
	 */
	private		$maxDepth = 0;

	/**
	 * Default contructor
	 */
	public function __construct() {
		$this->rustart = $this->startTiming();
	}

	/**
	 * Get the maximum depth of the deepest used node
	 * @return int
	 */
	public function getMaxDepth()
	{
		return $this->maxDepth;
	}

	/**
	 * Get the current state of the debug flag. If debugging is enabled then contexts are included in the report.
	 * @return boolean True is debugging output is currently enabled
	 */
	public function getDebugging()
	{
		return $this->debug;
	}

	/**
	 * Set the debug state
	 * @param string $state (defaults to false is not supplied)
	 * @return boolean The existing debug state
	 */
	public function setDebugging( $state = false )
	{
		$existingState = $this->debug;
		$this->debug = $state;
		return $existingState;
	}

	/**
	 * Add an instance document to the report
	 * @param string $instance_file The file name of the instance document to add the report
	 * @param string $taxonomy_file If provided the name of the .json or .zip file containing the taxonomy information
	 * @return void
	 */
	public function addInstanceDocument( $instance_file = null, $taxonomy_file = null, $useCache = false )
	{
		$this->log()->info( "$instance_file" );

		if ( $this->hierarchies !== null )
			throw new Exception( "An instance document cannot be added to a report once the report has been prepared" );

		if ( $instance_file === null )
			throw new Exception( "An instance document has not been supplied." );

		if ( isset( $this->instanceDocuments[ $instance_file ] ) )
			throw new Exception( "The instance document has already been loaded" );

		// Load the document
		/**
		 * An instance document instance
		 * @var XBRL_Instance $instance
		 */
		$instance = null;
		if ( ! XBRL_Instance::FromInstanceDocument( $instance_file, $taxonomy_file, $instance, false, $useCache ) )
		{
			throw new Exception( $instance->getError() );
		}

		// If no schema file is yet set, record it.  If the name of the taxonomy schema
		// associated with the instance document loaded is different to the schema of
		// a previously loaded instance document then report an error.
		$schemaFilename = $instance->getSchemaFilename();
		if ( $this->schemaFilename === null )
			$this->schemaFilename = $schemaFilename;
		else if ( $this->schemaFilename !== $schemaFilename )
			throw new Exception( "Instance documents being compared must use the the same taxonomy schema." );

		// Record it
		$this->instanceDocuments[ $instance_file ] =& $instance;
		$this->analyzeContexts( $instance );

		// If no taxonomy is set then record it as well.  Only one taxonomy is allowed per report.
		if ( ! isset( $this->taxonomy ) || $this->taxonomy === null )
			$this->taxonomy =& $instance->getInstanceTaxonomy();
	}

	/**
	 * Adds a valid year.  If none are added, all are valid.
	 * @param array[int]|int $year
	 */
	public function addValidYear( $year )
	{
		if ( is_array( $year ) )
		{
			$this->validYears += $year;
		}
		elseif ( $year !== null )
		{
			$this->validYears[] = $year;
		}
	}

	/**
	 * Removes any defined valid years.  After this function is called, all years are valid.
	 */
	public function clearValidYears()
	{
		$this->validYears = array();
	}

	/**
	 * Get the array of instance documents
	 * @return array[XBRL_Instance]
	 */
	public function getInstanceDocuments()
	{
		return $this->instanceDocuments;
	}

	/**
	 * Call to include default nodes in the output.  By default, defaults are included.
	 * @return void
	 */
	public function excludeDefaultDimensionMembers()
	{
		$this->includeDefaults = false;
	}

	/**
	 * Call to include default nodes in the output.  This is the default position.
	 * @return void
	 */
	public function includeDefaults()
	{
		$this->includeDefaults = true;
	}

	/**
	 * Initialize the taxonomy based on the loaded instance documents
	 * The taxonomy will have been loaded but the text may not have
	 * been assgined to concepts and the presentation hierarchy
	 * @return True if initialized successfully
	 */
	private function initTaxonomy()
	{
		// Sanity check
		if ( count( $this->instanceDocuments ) === 0 )
		{
			$this->log()->err( "There are no instance documents" );
			return false;
		}
		if ( $this->taxonomy === null ) return false;

		$xsd = pathinfo( $this->schemaFilename, PATHINFO_BASENAME );
		$this->taxonomy = $this->taxonomy->getTaxonomyForXSD( $xsd );

		return true;
	}

	/**
	 * Generate an alternative list of contexts by year
	 * Can be overridden descendant concrete implementations
	 * @param XBRL_Instance $instance The instance containing the contexts to analyze
	 */
	protected function analyzeContexts( $instance )
	{
		$contexts = $instance->getContexts()->getContexts();
		$elements = $instance->getElements()->getElements();

		foreach ( $elements as $elementKey => $element )
		{
			foreach ( $element as $entryKey => $entry )
			{
				if ( ! isset( $entry['contextRef'] ) )
					continue;

				if ( isset( $instance->usedContexts[ $entry['contextRef'] ] ) ) continue;

				$instance->usedContexts[ $entry['contextRef'] ] = $contexts[ $entry['contextRef'] ];
				$instance->usedContexts[ $entry['contextRef'] ]['year'] = substr( $contexts[ $entry['contextRef'] ]['period']['endDate'], 0, 4 );
			}
		}

		if ( ! is_array( $this->years ) ) $this->years = array();

		foreach ( $instance->usedContexts as $key => $context )
		{
			$year = $context['year'];
			$entity = $context['entity']['identifier']['value'];

			if ( ! isset( $this->years[ $year ] ) ) $this->years[ $year ] = array();
			if ( ! isset( $this->years[ $year ][ $entity ] ) ) $this->years[ $year ][ $entity ] = array();
			$this->years[ $year ][ $entity ][ $key ] = $context;
		}

		// ksort( $this->years );
		// print_r( array_keys( $this->years ) );

		if ( ! is_array( $this->entities ) ) $this->entities = array();

		foreach ( $instance->usedContexts as $key => $context )
		{
			$entity = $context['entity']['identifier']['value'];
			$this->entityInstanceMap[ $entity ] = $instance->getDocumentName();

			if ( ! isset( $this->entities[ $entity ] ) ) $this->entities[ $entity ] = array();
			$this->entities[ $entity ][ $key ] = $context;
		}
	}

	/**
	 * Access the taxonomy for instances used in this report
	 * This is only valid when an instance document have been loaded
	 * @return XBRL An instance of an XBRL class or derivative
	 */
	public function &getTaxonomy()
	{
		return $this->taxonomy;
	}

	/**
	 * Get the node for a path
	 *
	 * @param array $nodes An array of nodes
	 * @param string $path The path representing a node. A path is a set of labels concatenated by '/'
	 * @return boolean|array False if the node is not found or a reference to the node represented by the $path
	 */
	private function &findNodeFromPath( &$nodes, $path )
	{
		$pathsParts = explode( '/', $path );
		$node = null;

		for ( $i = 0; $i < count( $pathsParts ); $i++ )
		{
			if ( ! isset( $nodes[ $pathsParts[ $i ] ] ) )
			{
				$node = false;
				break;
			}

			$node =& $nodes[ $pathsParts[ $i ] ];

			if ( isset( $node['children'] ) )
			{
				$nodes =& $node['children'];
				continue;
			}
		}

		return $node;
	}

	/**
	 * Compare $entry with $existingElements to determine if the associated contextRefs are equivalent.
	 * @param array $existingElements An array of instance entries to compare to $entry for context and value equivalence
	 * @param array $entry An entry node representing a record in the instance document
	 * @param string $entryEntity The entity for which the entry should be unique
	 * @return bool Returns true if $entry is unique.
	 */
	private function entry_is_unique( $existingElements, $entry, $entryEntity )
	{
		if ( isset( $entry['tuple_elements'] ) ) return true;

		foreach ( $existingElements as $key => $existingElement )
		{
			if ( $existingElement['contextRef'] !== $entry['contextRef'] ) continue;
			if ( $existingElement['value'] !== $entry['value'] ) continue;
			if ( $existingElement['entity'] !== $entryEntity ) continue;
			// $this->log()->info( "The $entry with contextRef {$entry['contextRef']} and value {$entry['value']} is not unique" );
			return false;
		}
		return true;
	}

	/**
	 * Make sure the list of years (based on contexts) is the same as the specified valid year (if any have been specified)
	 * @return void
	 */
	private function alignWithValidYears()
	{
		// Remove any years that are not in the valid years list
		if ( ! $this->validYears ) return;

		$validYears = array_flip( $this->validYears );

		$validYears = array_intersect_key( $validYears, $this->years );
		$this->validYears = array_flip( $validYears );
		$this->years = array_intersect_key( $this->years, $validYears );
	}

	/**
	 * This is a core function that processes the instance documents and their
	 * elements against the presentation roles of the selected taxonomy.
	 * The result is a series of hierarchies (one for each presentation role in
	 * the selected taxonomy) that can be pruned to include only those elements
	 * for which at least one value is assigned.
	 *
	 * It is a four stage process:
	 *
	 * 1) Process the instance document to assign instance facts to nodes in the
	 *    presentation hierarchy and add convert hypercubes of primary item nodes
	 *    to dimensions and their members used by instance documents including defaults;
	 * 2) Prune any unused presentation hierarchy nodes
	 * 3) Call processDimensionGroups() to expand the discovered dimensions and
	 *    members into new nodes in the presentation hierarchy;
	 * 4) (optionally) call compactDimensionGroups to remove nodes that are unused
	 *    or are only used by default members (in which case the values are
	 *    promoted up the hierarchy to a non-default dimension member or a primary
	 *    item.
	 *
	 * @param bool $prune True if the presentation hierarchies should be pruned to keep only items with elements assigned
	 * @return void
	 */
	public function preparePresentation( $prune = true )
	{
		$this->log()->info( "initTaxonomy" );

		if ( ! $this->initTaxonomy() )
			throw new Exception( "Failed to initialize the taxonomy" );

		// $this->log()->info( "Prepare {$this->elapsedTime()}" );
		$roles = &$this->taxonomy->getPresentationRoleRefs();

		$taxonomies = $this->taxonomy->getImportedSchemas();
		$this->maxDepth = 0;

		$this->alignWithValidYears();

		foreach ( $this->instanceDocuments as $instanceKey => $instance )
		{
			/**
			 * @var $instance XBRL_Instance
			 */
			$instance_namespaces = $instance->getInstanceNamespaces();
			$instance_elements = $instance->getElements()->getElements();
			$count = count( $instance_elements );
			$this->log()->info( "There are $count elements to report" );

			foreach ( $instance_elements as $elementKey => &$instance_element )
			{
				// There may be more than one entry in each instance_element
				foreach ( $instance_element as $entryKey => &$entry )
				{
					// If valid years have been defined check to see if the
					if ( false && $this->validYears )
					{
						$year = $instance->getYearForElement( $entry );
						if ( ! $year )
						{
							// Probably a tuple so check any tuple elements
							// If it there are none, the node is invalid
							if ( ! isset( $entry['tuple_elements'] ) )
								continue;

							// Time to check the tuple members are valid for the valid year(s)
							// If they are not, they are removed
							foreach ( $entry['tuple_elements'] as $tupleKey => $tupleElements )
							{
								foreach ( $tupleElements as $tupleElementKey => $tupleElement )
								{
									$year = $instance->getYearForElement( $tupleElement );
									if ( ! $year || ! in_array( $year, $this->validYears ) )
									{
										unset( $entry['tuple_elements'][ $tupleKey ][ $tupleElementKey ] );
									}
								}

								if ( ! $entry['tuple_elements'][ $tupleKey ] )
								{
									unset( $entry['tuple_elements'][ $tupleKey ] );
								}
							}

							if ( ! $entry['tuple_elements'] ) continue;
						}
						else
						if ( ! in_array( $year, $this->validYears ) )
						{
							continue;
						}

					}

					// $this->log()->info( "Entry: {$entry['taxonomy_element']['id']}" );
					// Get the namespace for the entry's namespace prefix
					// if ( $entry['taxonomy_element']['id'] === 'uk-bus_AddressLine2' ) exit;
					// Get the taxonomy for the entry's namespace
					if ( ! isset( $instance_namespaces[ $entry['namespace'] ] ) )
						throw new Exception( "Unable to find the namespace for the prefix: {$entry['namespace']}" );

					$instance_namespace = $instance_namespaces[ $entry['namespace'] ];

					if ( ! isset( $taxonomies[ $instance_namespace ] ) )
						throw new Exception( "Unable to find a taxonomy for the namespace '$instance_namespace'" );

					/**
					 * @var XBRL $instance_taxonomy
					 */
					$instance_taxonomy = $taxonomies[ $instance_namespace ];

					if ( ! $instance_taxonomy )
						throw new Exception( "Unable to fund the taxonomy for the namespace '{$instance_namespaces[ $entry['namespace'] ]}'" );

					// Create an href so locators can be identified. The id alone should be enough but using an href is safer.
					// $xsd = $instance_taxonomy->getTaxonomyXSD();
					$href = $entry['label']; // "$xsd#{$entry['taxonomy_element']['id']}";

					$located_role_paths = array();  // The label can exist in more than one presentation role

					// Look for the label in the locators of each presentation role.
					// Use the href of the taxonomy element to find the locator and, so, the role.
					foreach ( $roles as $roleKey => $role ) // <- This has to be by reference or any changes are are lost!
					{
						// $this->log()->info( "Role key: $roleKey" );
						if ( ! isset( $role['paths'] ) )
							throw new Exception( "Error occurred: paths array not available on role $roleKey" );

						if ( ! isset( $role['paths'][ $entry['taxonomy_element']['id'] ] ) )
							continue;

						$located_role_paths[ $roleKey ] = $role['paths'][ $entry['taxonomy_element']['id'] ];
					}

					if ( count( $located_role_paths ) === 0 )
					{
						$this->log()->info( "Unable to find role for $href" );
						continue;
					}

					// Find the element in the located_role
					// $this->log()->info( "The role for {$elementKey} is {$located_role_key}" );
					// $this->log()->info( "href: $href" );

					// uk-gaap-pt_ApprovalDetails is an example of a concept that might
					// exist in the AE document but does not exist in the presentation
					// if ( $href === "uk-gaap-pt-2004-12-01.xsd#uk-gaap-pt_ApprovalDetails" )

					foreach ( $located_role_paths as $roleKey => $paths )
					{
						foreach ( $paths as $path )
						{
							$currentNodes =& $roles[ $roleKey ]['hierarchy'];
							if ( isset( $pathNode ) ) unset( $pathNode );
							$pathNode = false;
							$commonHypercubes = array();
							$totalHypercubes = array();
							$hypercubelessNodes = array();
							$currentPath = "";
							$validMembers = array();
							unset( $dimInfo );
							unset( $totalDimensions );

							$pathsParts = explode( '/', $path );
							for ( $i = 0; $i < count( $pathsParts ); $i++ )
							{
								if ( ! isset( $currentNodes[ $pathsParts[ $i ] ] ) )
								{
									$this->log()->err( "This is bad" );
									$currentNodes = false;
									break;
								}

								if ( $pathNode )
								{
									$currentNodes[ $pathsParts[ $i ] ]['parentNode'] =& $pathNode;
								}

								$pathNode =& $currentNodes[ $pathsParts[ $i ] ];
								if ( ! isset( $pathNode['text'] ) )
								{
									// $element_xsd = parse_url( $pathNode['label'], PHP_URL_PATH );
									$taxonomy = $this->getTaxonomy()->getTaxonomyForXSD( $pathNode['label'] );
									$pathNode['taxonomy_element'] = $taxonomy->getElementById( $pathNode['label'] );
									// $key = $pathNode['label']; // "$element_xsd#{$pathNode['taxonomy_element']['id']}";

									$pathNode['text'] = $instance_taxonomy->getTaxonomyDescriptionForIdWithDefaults(
										$taxonomy->getTaxonomyXSD() . "#{$pathNode['taxonomy_element']['id']}", /*$pathNode['label'], */
										isset( $pathNode['preferredLabel'] ) ? $pathNode['preferredLabel'] : null,
										$instance_taxonomy->getDefaultLanguage()
									);
									if ( ! $pathNode['text'] )
									{
										$pathNode['text'] = $pathNode['label'];
									}
								}

								$currentPath = ( empty( $currentPath ) ? "" : $currentPath . "/" ) . $pathsParts[ $i ];

								/*
								 * This code has to collect the hypercubes from the 'hypercubes' and the 'common' elements
								 * To new hypercubes or new common hypercubes the current path is added an element called
								 * 'path'.  This is so the correct node can be found when adding dimensions.  This way the
								 * dimensions are added to the appropriate node.
								 */

								// Collect the hypercubes
								$nodeHypercubes = ( isset( $pathNode['hypercubes'] ) ? $pathNode['hypercubes'] : array() )
												+ ( isset( $pathNode['common'] ) ? $pathNode['common'] : array() );

								// Identify any new hypercubes (not already in the common collection)
								$newHypercubes = array_diff_key( $nodeHypercubes, $commonHypercubes );

								// Assign the current path to any new hypercubes
								foreach ( $newHypercubes as $hcKey => $hc )
								{
									$newHypercubes[ $hcKey ]['path'] = $currentPath;
								}

								// The common list for the next go around is the existing common list plus the new hypercubes
								// $commonHypercubes = array_merge_recursive( $commonHypercubes,  $newHypercubes );
								$commonHypercubes += $newHypercubes;
								$totalHypercubes = $commonHypercubes; // Looks like $totalHypercubes = $commonHypercubes are the same thing

								if ( ! isset( $pathNode['children'] ) )
								{
									// Better be the last!
									if ( count( $pathsParts ) -1 > $i )
									{
										$this->log()->crit( "There are no child nodes but node '{$pathNode['label']}' is not the last part in path '$path'" );
										exit;
									}

									continue;
								}

								$currentNodes =& $pathNode['children'];
							} // for $pathParts

							if ( ! $currentNodes )
							{
								$this->log()->warning( "There are no current nodes so something went wrong evaluation path '$path'" );
								continue;
							}

							if ( ! $pathNode )
							{
								$this->log()->warning( "A node cannot be found for path '$path'" );
								continue;
							}

							$entryEntity = $instance->getEntityForElement( $entry );

							// If the node does not have any existing instance elements assigned add an empty element
							// If instance elements have been assigned, check its not a duplicate
							if ( ! isset( $pathNode['elements'] ) )
								$pathNode['elements'] = array();
							else if ( ! $this->entry_is_unique( $pathNode['elements'], $entry, $entryEntity ) )
								continue;

							// $this->log()->info( "Found entry: {$entry['taxonomy_element']['id']} ({$entry[ 'contextRef' ]})" );
							$context_dimensions = array();
							// contextRef will not exist if the entry element is a tuple
							$preferredLabels = array_reduce( $totalHypercubes, function( $carry, $hypercube ) {
								if ( ! isset( $hypercube['preferredLabel'] ) ) return $carry;
								$carry[] = $hypercube['preferredLabel'];
								return $carry;
							}, array() );
							$dimInfo = isset( $entry['contextRef'] ) ? $instance->getElementsForContext( $entry['contextRef'], $preferredLabels ) : false;
							if ( $dimInfo !== false )
							{
								foreach ( $dimInfo as $dimInfoKey => $item )
								{
									if ( ! isset( $item['dimension']['element']['id'] ) ||
										 ! isset( $item['member']['element']['id'] ) ) continue;

									$dimTax = $instance_taxonomy->getTaxonomyForNamespace( $item['dimension']['namespace'] );
									$dimXSD = $dimTax->getTaxonomyXSD();

									$memTax = $instance_taxonomy->getTaxonomyForNamespace( $item['member']['namespace'] );
									$memXSD = $memTax->getTaxonomyXSD();

									$context_dimensions[ "$dimXSD#{$item['dimension']['element']['id']}" ] = array(
										'member' => "$memXSD#{$item['member']['element']['id']}",
										'member_text' => $item['member']['text'],
										'dimension_text' => $item['dimension']['text'],
										'member_taxonomy_element' => $item['member']['element'],
									);
								}

								// Look to see if any taxonomy specific additional members exist for members of the parts path
								$validMembers += $instance_taxonomy->getValidDimensionMembersForNode( $pathNode, $pathsParts );

								// Check that any dimension members are valid against the context members.
								// TODO: probably only need to check for members of explicit dimensions
								if ( count( $validMembers ) > 0 && count( $context_dimensions ) > 0 )
								{
									$context_members = array_map( function( $item ) { return $item['member']; }, $context_dimensions );
									$foundMembers = array_intersect_key( $validMembers, array_flip( $context_members ) );
									if ( count( $context_members ) > count( $foundMembers ) )
									{
										// $this->log()->warning( "Not all context members are valid in this role" );
										continue;
									}
								}

							}

							// Record the $entry
							if ( isset( $pathEntry ) ) unset( $pathEntry );
							$pathEntry = $entry;
							$pathNode['elements'][] =& $pathEntry;
							$pathNode['used'] = 'value';
							$usedNode =& $pathNode;

							$pathEntry['entity'] = $entryEntity;

							while ( isset( $usedNode['parentNode'] ) )
							{
								// get the parent node
								$usedNode =& $usedNode['parentNode'];
								// If the node has already been used, we're done
								if ( isset( $usedNode['used'] ) ) continue;
								// Flag the path as used
								$usedNode['used'] = 'path';
							}

							unset( $usedNode );

							$pathNode['taxonomy_namespace'] = $instance_namespaces[ $entry['namespace'] ];
							$label = $href;

							if ( isset( $entry['tuple_elements'] ) )
							{
								$pathNode['tuple'] = true;
							}

							// Find the dimensions and member from the context or get the default for the dimension.
							else if ( isset( $pathNode['nodeclass'] ) && $pathNode['nodeclass'] === "primaryitem" && ! in_array( $label, $hypercubelessNodes ) )
							{
								// Getting here means there are dimensions for the node.
								// The dimensions could be those passed as common or associated directly with the node

								// $this->log()->info( "$path/{$pathNode['label']}" );
								// $this->log()->info( "Common" );
								// $this->log()->info( $commonHypercubes );

								if ( ! isset( $pathEntry['validCombination'] ) ) $pathEntry['validCombination'] = array();

								$totalDimensions = array();

								foreach ( $totalHypercubes as $hypercubeKey => $hypercube )
								{
									// $this->log()->info( "$hypercubeKey" );
									$tax = $instance_taxonomy->getNamespace() === $hypercube['namespace']
										? $instance_taxonomy
										: $instance_taxonomy->getTaxonomyForNamespace( $hypercube['namespace'] );

									if ( $tax === false ) continue;

									$role_hypercubes = $tax->getDefinitionRoleHypercubes( $hypercube['role'] );
									if ( $role_hypercubes === false || ! isset( $role_hypercubes[ $hypercubeKey ] ) )
									{
										$this->log()->warning( "Unable to find the hypercube '$hypercubeKey' in role '{$hypercube['role']}' of the hypercube set for taxonomy '{$hypercube['namespace']}'" );
										continue;
									}

									if ( isset( $role_hypercubes[ $hypercubeKey ]['dimensions'] ) )
									{
										foreach ( $role_hypercubes[ $hypercubeKey ]['dimensions'] as $dimensionKey => $dimension )
										{
											if ( ! isset( $totalDimensions[ $dimensionKey ] ) )
											{
												// $this->log()->info( "$dimensionKey" );
												$dimension['hypercube'] = array( $hypercubeKey => $hypercube['role'] );
												$dimension['path'] = $hypercube['path'];
												$totalDimensions[ $dimensionKey ] = $dimension;
											}
											else
											{
												$totalDimensions[ $dimensionKey ]['hypercube'][ $hypercubeKey ] = $hypercube['role'];
												if ( $totalDimensions[ $dimensionKey ]['path'] !== $hypercube['path'] &&
													 strlen( $totalDimensions[ $dimensionKey ]['path'] ) > strlen( $hypercube['path'] )  )
												{
													$totalDimensions[ $dimensionKey ]['path'] = $hypercube['path'];
												}
											}

											if ( isset( $dimension['default'] ) )
											{
												/**
												 * @var XBRL $tax
												 */
												$tax = $instance_taxonomy->getTaxonomyForXSD( $dimension['default']['label'] );

												$dimension['default']['taxonomy_element'] = $tax->getElementById( $dimension['default']['label'] );

												$pathEntry['validCombination'][ $dimensionKey ] = $tax->getTaxonomyXSD() . "#{$dimension['default']['taxonomy_element']['id']}";
												// $key = parse_url( $dimensionKey, PHP_URL_FRAGMENT );
												// $pathEntry['validCombination'][ $key ] = $dimension['default']['taxonomy_element']['id'];
											}
										}
									}
								}

								if ( $dimInfo === false )
								{
									// There are dimensions (local and common) but the context does not specify members for any dimensions
									// Now it the chance to find the default values

									// If there are no dimension then its not necessarily a problem.
									$allPossibleDimensions = array_reduce( $totalHypercubes, function( $carry, $hypercube ) {
										$carry += isset( $hypercube['dimensioncount'] ) ? $hypercube['dimensioncount'] : 0; return $carry;
									}, 0 );

									// If there are no dimensions (eg primary item for an 'empty' hypercube) then all is good
									if ( $allPossibleDimensions == 0 )
									{
										// $pathEntry['nodim'] = true; // Used by processDimensionGroups
										continue;
									}

									if ( count( $totalDimensions ) > 0 )
									{
										// All the dimensions for all the hypercubes must have a default member
										$invalidHypercubes = array_reduce( $totalHypercubes, function( $carry, $hypercube) use( $totalDimensions ) {
											$allDefaultDimensions = array_reduce( $totalDimensions, function( $carry, $dimension ) use( $hypercube ) {
												return $carry += isset( $dimension['hypercube'][ $hypercube['href'] ] ) && isset( $dimension['default'] ) ? 1 : 0;
											}, 0 );

											if ( $allDefaultDimensions != $hypercube['dimensioncount'] )
											{
												$carry[] = $hypercube['href'];
											}

											return $carry;
										}, array() );

										if ( count( $invalidHypercubes ) == count( $totalHypercubes ) )
										{
											/*
											$this->log()->instance_validation(
												"[Ins Err, 2]",
												"All the hypercubes have no dimensions with default members.  This is required because no context dimension information is supplied",
												array(
													STANDARD_PREFIX_XBRLDI_ERROR => 'PrimaryItemDimensionallyInvalidError',
													'definition' => 21,
													'id' => $entry['taxonomy_element']['id'],
													'context' => $entry['contextRef'],
													'hypercubes' => $invalidHypercubes,
												)
											);
											 */
											// This hypercube is not valid so only report the value
											array_pop( $pathNode['elements'] );
											continue;
										}

										// Remove hypercubes that are invalid.  This does not appear to happen.
										if ( $invalidHypercubes )
										{
											// $totalHypercubes = array_diff_key( $totalHypercubes, array_flip( $invalidHypercubes ) );

											// Remove any dimensions associated soley with invalid hypercubes
											foreach ( $totalDimensions as $dimKey => $dimension )
											{
												// if ( $dimension['hypercube'] )
											}
										}

									}
								}
								else
								{
									// The count of total dimensions should be the same or at least one of the hypercubes should
									// not be closed.
									$allHypercubesAreClosed = array_reduce( $totalHypercubes, function( $carry, $hypercube ) {
										return $carry || ( isset( $hypercube['closed'] ) && $hypercube['closed'] );
									}, false );

									if ( count( $totalDimensions ) < count( $context_dimensions ) && $allHypercubesAreClosed )
									{
										/*
										$this->log()->instance_validation(
											"[Ins Err, 2]",
											"Dimensions are defined by the context that do not exist in the hypercube and the hypercube is closed.",
											array(
												STANDARD_PREFIX_XBRLDI_ERROR => 'PrimaryItemDimensionallyInvalidError',
												'definition' => 21,
												'id' => $entry['taxonomy_element']['id'],
												'context' => $entry['contextRef'],
											)
										);
										*/
										// This node is not valid
										array_pop( $pathNode['elements'] );
										continue;
									}

									$pathEntry['context_dimensions'] = $context_dimensions;
								}

								// Look in the common dimensions
								$matched_node_dimensions = array_intersect_key( $totalDimensions, $context_dimensions );
								// Create a list of all the hypercubes that apply to this element
								$hc = array_reduce( $matched_node_dimensions, function( $carry, $item ) { return array_merge( $carry, $item['hypercube'] ); }, array() );
								// Add all the hypercubes having a dimension in $totalDimensions that have a default member
								// TODO: This should be to add the hypercube if *all* its dimensions have defaults.  If even one
								//       does not have a default then its not a valid hypercube (see https://www.xbrl.org/specification/dimensions/rec-2012-01-25/dimensions-rec-2006-09-18+corrected-errata-2012-01-25-clean.html#term-dimensionally-valid-with-respect-to-a-hypercube)
								$hc = array_reduce( $totalDimensions, function( $carry, $item ) use( $context_dimensions ) {
									if ( ! isset( $item['default'] ) ) return $carry;
									return array_merge( $carry, $item['hypercube'] );
								}, $hc );

								// Filter the total dimensions list to include only those that share hypercubes used by this element
								$totalDimensions = array_filter( $totalDimensions, function( $item ) use( $hc ) {
									return count( array_intersect_key( $item['hypercube'], $hc ) );
								});

								$matched_context_dimensions			= array_intersect_key( $context_dimensions, $totalDimensions );
								// $matched_node_dimensions			= array_intersect_key( $totalDimensions, $context_dimensions );
								$count_context_dimensions			= count( $context_dimensions );
								$count_matched_context_dimensions	= count( $matched_context_dimensions );

								// All the context dimensions should be matched
								if ( $count_context_dimensions > $count_matched_context_dimensions )
								{
									// This is just invalid so remove the element and move on.
									array_pop( $pathNode['elements'] );
									continue;

									$diff = array_keys( array_diff_key( $context_dimensions, $matched_context_dimensions ) );
									$dims = implode( ", ", $diff );
									$this->log()->warning( "Not all context dimensions have been matched by dimensions for node '{$pathNode['label']}' and context '{$entry['contextRef']}' ($dims)" );
									$this->log()->warning( "	There are $count_context_dimensions context dimension(s) but $count_matched_context_dimensions matched context dimensions" );
									$this->log()->warning( "Value: {$entry['value']}" );
									// print_r( array_keys( $totalDimensions ) );
									// exit;
									continue;
								}

								$matched = array_merge_recursive( $matched_context_dimensions, $matched_node_dimensions );
								foreach ( $matched as $dimensionKey => $dimension )
								{
									if ( isset( $dimNode ) ) unset( $dimNode );
									$dimNode = array();
									$dimNode = &$this->findNodeFromPath( $roles[ $roleKey ]['hierarchy'], $dimension['path'] );
									if ( ! $dimNode )
									{
										$this->log()->warning( "Unable to find node for dimensions" );
										continue;
									}

									if ( ! isset( $dimension['taxonomy_element'] ) )
									{
										/**
										 * @var XBRL $tax
										 */
										$dimTax = $instance_taxonomy->getNamespace() === $dimension['dimension_namespace']
											? $instance_taxonomy
											: $instance_taxonomy->getTaxonomyForNamespace( $dimension['dimension_namespace'] );
										$dimension['taxonomy_element'] = $dimTax->getElementById( $dimension['label'] );
									}

									if ( ! isset( $dimNode['dimensions'] ) ) $dimNode['dimensions'] = array();
									if ( ! isset( $dimNode['dimensions'][ $dimensionKey ] ) )
									{
										$dimNode['dimensions'][ $dimensionKey ] = array(
											'label'				=> $dimensionKey,
											'text'				=> $dimension['dimension_text'],
											'targetRole'		=> isset( $dimension['targetRole'] ) ? $dimension['targetRole'] : "",
											'hypercube'			=> $dimension['hypercube'],
											'taxonomy_element'	=> $dimension['taxonomy_element'],
											'order'				=> $dimension['order'],
										 );

										if ( isset( $dimension['default'] ) )
										{

											/**
											 * @var XBRL $tax
											 */
											$tax = $instance_taxonomy->getTaxonomyForXSD( $dimension['default']['label'] );

											if ( ! isset( $dimension['default']['taxonomy_element'] ) )
											{
												$dimension['default']['taxonomy_element'] = $tax->getElementById( $dimension['default']['label'] );
											}

											$member_text = $tax
												? $tax->getTaxonomyDescriptionForIdWithDefaults( $dimension['default']['taxonomy_element']['id'] )
												: $dimension['default']['taxonomy_element']['id'];

											$default_label = $tax->getTaxonomyXSD() . "#" . $dimension['default']['taxonomy_element']['id'];

											// $member = XBRL::findDimensionMember( $dimension['members'], $default_label );

											$dimNode['dimensions'][ $dimensionKey ]['default'] = array(
												'label'				=> $default_label,
												'text'				=> $member_text,
												'taxonomy_element'	=> $dimension['default']['taxonomy_element'],
												'order'				=> $dimension['order'],
											);
										}
									}

									if ( ! isset( $dimNode['dimensions'][ $dimensionKey ]['members'] ) )
									{
										$dimNode['dimensions'][ $dimensionKey ]['members'] = array();
									}

									if ( ! isset( $dimNode['dimensions'][ $dimensionKey ]['members'][ $dimension['member'] ] ) )
									{
										$dimNode['dimensions'][ $dimensionKey ]['members'][ $dimension['member'] ] = array(
											'label'				=> $dimension['member'],
											'text'				=> $dimension['member_text'],
											'taxonomy_element'	=> $dimension['member_taxonomy_element'],
											'order'				=> $dimension['order'],
										);
									}

									// $pathEntry['validxCombination'][ $tax->getTaxonomyXSD() . "#{$dimensionKey}" ] = $tax->getTaxonomyXSD() . "#{$dimension['member']}";
									$pathEntry['validCombination'][ $dimensionKey ] = $dimension['member'];

								}

								// For the dimensions not matched find any available defaults
								$notMatched = array_diff_key( $totalDimensions, $matched );
								foreach ( $notMatched as $dimensionKey => $dimension )
								{
									if ( ! isset( $dimension['default'] ) ) continue;

									if ( isset( $dimNode ) ) unset( $dimNode );

									$dimNode = array();
									$dimNode = &$this->findNodeFromPath( $roles[ $roleKey ]['hierarchy'], $dimension['path'] );
									if ( ! $dimNode ) continue;

									if ( ! isset( $dimNode['dimensions'] ) ) $dimNode['dimensions'] = array();
									if ( ! isset( $dimNode['dimensions'][ $dimensionKey ] ) )
									{
										// Get the labels for the defaults
										/**
										 * @var XBRL $member_tax
										 */
										$member_tax = $instance_taxonomy->getNamespace() === $dimension['default']['namespace']
											? $instance_taxonomy
											: $instance_taxonomy->getTaxonomyForNamespace( $dimension['default']['namespace'] );

										if ( ! isset( $dimension['default']['taxonomy_element'] ) )
										{
											$dimension['default']['taxonomy_element'] = $member_tax->getElementById( $dimension['default']['label'] );
										}

										$member_text = $member_tax
											? $member_tax->getTaxonomyDescriptionForIdWithDefaults( $dimension['default']['taxonomy_element']['id'] )
											: $dimension['default']['taxonomy_element']['id'];

										/**
										 * @var XBRL $dim_tax
										 */
										$dim_tax = $instance_taxonomy->getNamespace() === $dimension['dimension_namespace']
											? $instance_taxonomy
											: $instance_taxonomy->getTaxonomyForNamespace( $dimension['dimension_namespace'] );

										if ( ! isset( $dimension['taxonomy_element'] ) )
										{
											$dimension['taxonomy_element'] = $dim_tax->getElementById( $dimension['label'] );
										}

										// Get the taxonomy for the dimension
										$dimension_text = $dim_tax
											? $dim_tax->getTaxonomyDescriptionForIdWithDefaults( $dimensionKey )
											: $dimensionKey;

										if ( ! $dimension_text )
										{
											$dimension_text = $dim_tax
												? $dim_tax->getTaxonomyDescriptionForIdWithDefaults( $dimension['taxonomy_element']['id'] )
												: $dimensionKey;

											if ( $dimension_text && isset( $dim_tax->context->missingLabels[ $dimensionKey ] ) )
											{
												unset( $dim_tax->context->missingLabels[ $dimensionKey ] );
											}
										}

										$default_member_label = $dimension['default']['label']; // $member_tax->getTaxonomyXSD() . "#" . $dimension['default']['taxonomy_element']['id'];
										$refs =& $member_tax->getDefinitionRoleRefs();

										$dimNode['dimensions'][ $dimensionKey ] = array(
											'label'				=> $dimensionKey,
											'text'				=> $dimension_text,
											'targetRole'		=> isset( $dimension['targetRole'] ) ? $dimension['targetRole'] : "",
											'hypercube'			=> $dimension['hypercube'],
											'taxonomy_element'	=> $dimension['default']['taxonomy_element'],
											'order'				=> $dimension['order'],
											'default'			=> array(
												'label'				=> $default_member_label,
												'text'				=> $member_text,
												'taxonomy_element'	=> $dimension['default']['taxonomy_element'],
												'order'				=> $dimension['order'],
											),
										);
									}
								}
							}
							else
							{
								if ( $dimInfo !== false )
								{
									// $this->log()->warning(  "The node requires no dimension information but the context includes dimension information." );
									array_pop( $pathNode['elements'] );
									continue;
								}
							}
						}
					} // $located_role_keys
				} // $entries
			} // $instance_elements
		} // $this->instanceDocuments

		// if ( $this->debug ) $this->log()->debug( "After prepare: {$this->elapsedTime()}" );
		// Start pruning the tree.

		if ( $prune )
		{
			// if ( $this->debug ) $this->log()->debug( "Before prune: {$this->elapsedTime()}" );
			$this->pruneNodes( $roles );
		}
		// file_put_contents( 'output.json', json_encode( $this->hierarchies ) );

		// if ( $this->debug ) $this->log()->debug( "Compact: {$this->elapsedTime()}" );
		$this->hierarchies = array();
		$processTotal = 0;
		$compactTotal = 0;

		foreach ( $roles as $roleKey => &$role )
		{
			// For the purpose of debugging only add the EntityInformation role
			// if ( $roleKey !== 'http://www.xbrl.org/uk/cd/role/Entity-Information' ) continue;
			// if ( $roleKey !== 'http://www.xbrl.org/uk/role/ProftAndLossAccount' ) continue;
			// if ( $roleKey !== 'http://www.xbrl.org/uk/role/Notes' ) continue;
			// if ( $roleKey !== 'http://www.xbrl.org/uk/role/ReconciliationMovementsShareholderFunds' ) continue;
			// if ( $roleKey !== 'http://www.xbrl-uk.org/ExtendedLinkRoles/AE-Notes-to-Accounts' ) continue;
			// if ( $roleKey !== 'http://www.mgcdiagnostics.com/role/DisclosureAcquisitionScheduleOfRevisionsToConsolidatedBalanceSheetDetails' ) continue;
			// if ( $roleKey !== 'http://www.mgcdiagnostics.com/role/DisclosureIntangibleAssetsScheduleOfIntangibleAssetsDetails' ) continue;
			// if ( $roleKey !== 'http://www.mgcdiagnostics.com/role/DisclosureIntangibleAssetsScheduleOfIntangibleAssetsDetails' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/ConsolidatedStatementsOfChangesInEquity' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/ConsolidatedStatementsOfFinancialCondition' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/ConsolidatedStatementsOfCashFlows' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/AccountingDevelopments' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/FairValueDisclosuresAdditionalInformationDetail' ) continue;
			// if ( $roleKey !== 'http://www.jefferies.com/role/FairValueDisclosuresQuantitativeInformationAboutSignificantUnobservableInputsUsedInLevel3FairValueMeasurementsDetail' ) continue;
			// if ( $roleKey !== 'http://pharmabioserv.com/role/I.StockOptionsAndStockBasedCompensationDetails' ) continue;
			// if ( $roleKey !== 'http://questmanagement.com/role/StatementsOfCashFlows' ) continue;
			// if ( $roleKey !== 'http://www.xbrl.org/uk/org/role/BalanceSheetStatement' ) continue;

			$this->leafCount = 0;

			$this->log()->info( "$roleKey" );

			// $before = $this->elapsedTime();

			$test = false;
			if ( $test )
			{
				// if ( $roleKey !== 'http://pharmabioserv.com/role/StatementsOfChangesInStockholdersEquity' ) continue;
				$nodes = array();
				$this->processDimensionGroups2( $role['hierarchy'], $nodes );
				$hierarchy = $nodes['children'];
				// exit;
			}
			else
			{
				$hierarchy = $this->processDimensionGroups( $role['hierarchy'] );
			}
			// $after = $this->elapsedTime();
			// $processTime = $after - $before;
			// $processTotal += $processTime;

			// $before = $this->elapsedTime();
			$this->compactDimensionGroups( $hierarchy );
			// $after = $this->elapsedTime();
			// $compactTime = $after - $before;
			// $compactTotal += $compactTime;

			//$this->log()->info( "{$this->leafCount} $processTime $compactTime $roleKey" );
			$this->countDepth( $hierarchy );

			$this->hierarchies[ $roleKey ] = array(
				'text'		=> $role['text'],
				'hierarchy' => $hierarchy,
			);
		}

		// $this->log()->info( "Process time: $processTotal" );
		// $this->log()->info( "Compact time: $compactTotal" );

		// file_put_contents( 'output.json', json_encode( $this->hierarchies ) );
		// $this->log()->info( json_encode( $this->hierarchies ) );
	}

	/**
	 * Set the max depth
	 * @param array $nodes The current hierarchy nodes
	 * @param int $depth The current depth
	 */
	private function countDepth( &$nodes, $depth = 0 )
	{
		if ( $depth > $this->maxDepth ) $this->maxDepth = $depth;

		foreach ( $nodes as $nodeKey => &$node )
		{
			$node['depth'] = $depth;

			if ( ! isset( $node['children'] ) || count( $node['children'] ) === 0 ) continue;
			$this->countDepth( $node['children'], $depth + 1 );
		}
	}

	/**
	 * Export the hierarchy to a file in JSON format
	 * @param string $filename
	 * @param bool $zip (Optional) Indicates whether the file should be zipped (Default: false)
	 * @return bool|string True if successful or a string reporting the issue
	 */
	public function saveGeneratedHierarchy( $filename, $zip = false )
	{
		$result = true;

		if ( ! property_exists( $this, 'hierarchies' ) ) return "The hierarchies have not been generated";
		$json = json_encode( $this->hierarchies );
		if ( json_last_error() !== JSON_ERROR_NONE )
		{
			$result = "An error occurred generating the JSON for the hierarchies: " . XBRL::json_last_error_msg();
		}
		elseif ( $zip )
		{
			$zip = new ZipArchive();
			$zip->open( $filename, ZipArchive::CREATE );
			if ( ! $zip->addFromString( 'hierarchies.json', $json ) )
			{
				$result = "Failed to add JSON to zip file";
			}

			if ( $zip->close() === false )
			{
				$result = "Error closing zip file: " . $zip->getStatusString();
			}
		}
		else
		{
			if ( file_put_contents( $filename, $json ) === false )
			{
				$result = "Writing to the file failed";
			}
		}

		return $result;
	}

	/**
	 * Load the hierachies from a JSON store
	 * @param string $filename
	 * @return bool|string True if successful or a string reporting the issue
	 */
	public function loadGeneratedHierarchy( $filename )
	{
		$result = true;

		$extension = strtolower( pathinfo( $filename, PATHINFO_EXTENSION ) );

		if ( $extension === 'zip' )
		{
			$zip = new ZipArchive();
			if ( $zip->open( $filename ) === true )
			{
				$json = $zip->getFromName( 'hierarchies.json' );
				$zip->close();
			} else
			{
				$result = 'Failed to open zip file $filename';
			}
		}
		else
		{
			$json = file_get_contents( $filename );
		}

		if (  $result )
		{
			$this->hierarchies = json_decode( $json, true );
			if ( json_last_error() !== JSON_ERROR_NONE )
			{
				$result = "An error occurred generating the JSON for the hierarchies: " . XBRL::json_last_error_msg();
			}

			$this->alignWithValidYears();

			foreach ( $this->hierarchies as $roleKey => $role )
			{
				$this->countDepth( $role['hierarchy'] );
			}

		}

		return $result;
	}

	/**
	 * Called to remove default members from the tree. If the default member is the only member then the dimension will be lost.
	 * @param array $nodes A collection of nodes to be analyzed and compacted
	 * @param string $path
	 * @return void
	 */
	private function compactDimensionGroups( &$nodes, $path = "" )
	{
		if ( $this->includeDefaults ) return;

		foreach ( $nodes as $nodeKey => &$node )
		{
			// If there are no children then its a leaf node so there is nothing to do
			if ( ! isset( $node['children'] ) || count( $node['children'] ) === 0 ) continue;

			// Process nodes recursively
			$this->compactDimensionGroups( $node['children'], "$path/{$node['label']}" );

			if ( isset( $child ) ) unset( $child );

			// Once the child nodes have been processed, compact this node
			// This node will be compacted if there is only one child and that child is the default member
			if ( ( $node['nodeclass'] ?? '' )=== 'dimension' )
			{
				// If its a dimension node does the node have a default member?
				// If there are only non-default children keep this node
				if ( ! ( $node['hasdefault'] ?? false ) ) continue;

				// If it has a default member is there only one member?
				if ( ! isset( $node['children'] ) ) continue;
				if ( count( $node['children'] ) > 1 ) continue;

				// Is the child the default node?
				// Child may have been set before
				// unset( $child );
				$child = reset( $node['children'] );
				if ( ! isset( $child['default'] ) || ! $child['default'] ) continue;

				$retainChildren = isset( $child['retainchildren'] );
				if ( $retainChildren ) $node['retainchildren'] = true;

				// The child is the only member and it is a default,  It can be removed.
				if ( isset( $child['elements'] ) )
				{
					// Bump the elements of the child up to the current node
					$node['elements'] = $child['elements'];

					if ( ! $retainChildren )
					{
						// Remove the child as a member of 'children' if it exists
						if ( isset( $node['children'][ $child['label'] ] ) )
						{
							unset( $node['children'][ $child['label'] ] );
							unset( $node['children'] );
						}
					}
				}
				else
				{
					$retainChildren = true;
					$node['defaulttext'] = $child['text'];
				}

				if ( $retainChildren )
				{
					// Bump the children up.  This is legit and will not override any other children
					// because the check above confirms this is the only child of $node
					$node['children'] = $child['children'];
					// Child may have been set before
					unset( $child );
					// And reset the parent
					foreach ( $node['children'] as $childKey => &$child )
					{
						$child['parent'] = $node['label'];
					}
				}

				$node['default'] = true;
			}
			elseif ( ( $node['nodeclass'] ?? '' ) === 'member' )
			{
				// If its a member node is it a default member?
				if ( ( ! isset( $node['default'] ) || ! $node['default'] ) &&
					 ! array_reduce( $node['children'], function( $carry, $item ) { return $carry === true ? true : isset( $item['default'] ) && $item['default']; }, false )
				   ) continue;

				// If it's a dimension,then process any children.  If the child is a dimension
				// without children delete it as it has been processed and found to be have
				// only default members.

				foreach ( $node['children'] as $childKey => $child )
				{
					if ( ( $child['nodeclass'] ?? '' ) === 'dimension' && ( $child['default'] ?? false ) )
					{
						// If the child is the only member and it is a default then it can be removed.
						if ( isset( $child['elements'] ) && count( $child['elements'] ) > 0 ) continue;
						if ( isset( $child['children'] ) && count( $child['children'] ) > 0 ) continue;
						unset( $node['children'][ $childKey ] );
					}
					else if ( $child['nodeclass'] === 'primaryitem' )
					{
						$node['retainchildren'] = true;
					}
				}

				// If there is more than one child or none then move along
				if ( ! isset( $node['children'] ) || count( $node['children'] ) !== 1 ) continue;

				// If there is only one child remaining then if it has elements promote them as elements of this node
				// Child may have been set before
				unset( $child );
				$child = reset( $node['children'] );
				if ( ( $child['nodeclass'] ?? '' ) !== 'primaryitem' )
				{
					if ( ( $child['nodeclass'] ?? '' ) === 'dimension' && isset( $child['children'] ) && count( $child['children'] ) > 1 )
					{
						// Or are all the children non-dimensional (eg primary items)?
						if ( count( array_filter( $child['children'] ?? array(),
							function( $node ) {
								return ( $node['nodeclass'] ?? '' ) === 'dimension' ||
								$node['nodeclass'] === 'member';
							} ) ) !== 0
						)
						continue;
					}

					$retainChildren = isset( $child['retainchildren'] );
					if ( $retainChildren ) $node['retainchildren'] = true;

					if ( isset( $child['elements'] ) && count( $child['elements'] ) > 0 )
					{
						if ( isset( $node['elements'] ) )
						{
							// $node['elements'] = array_merge( $node['elements'], $child['elements'] );
							foreach ( $child['elements'] as $elementKey => $element )
							{
								if ( ! $this->entry_is_unique( $node['elements'], $element, $element['entity'] ) ) continue;
								$node['elements'][] = $element;
							}
						}
						else
						{
							$node['elements'] = $child['elements'];
						}

						if ( ! $retainChildren )
						{
							if ( isset( $node['children'][ $child['label'] ] ) )
							{
								unset( $node['children'][ $child['label'] ] );
								unset( $node['children'] );
							}
						}
					}
					else
					{
						$retainChildren = true;
					}

					if ( $retainChildren )
					{
						$node['children'] = $child['children'];
						// Child may have been set before
						unset( $child );
						foreach ( $node['children'] as $childKey => &$child )
						{
							$child['parent'] = $node['label'];
						}
					}

					$node['default'] = true;
				}
			}
			else
			{
				// The node is not dimension or member so check to see if the only child is a default
				// If it is, remove it.
				if ( ! isset( $node['children'] ) ) continue;
				if ( count( $node['children'] ) === 0 )
				{
					unset( $node['children'] );
					continue;
				}

				// There's more than one so move along
				if ( count( $node['children'] ) > 1 ) continue;

				// Is the child a dimension?
				// unset( $child );
				$child = reset( $node['children'] );
				if ( ( $child['nodeclass'] ?? '' ) !== 'dimension' ) continue;
				if ( isset( $child['children'] ) && count( $child['children'] ) > 1 )
				{
					// Or are all the children non-dimensional (eg primary items)?
					if ( count( array_filter( $child['children'],
						function( $node ) {
							return $node['nodeclass'] === 'dimension' ||
							$node['nodeclass'] === 'member';
						} ) ) !== 0
					)
					continue;
				}

				// OK, is the child a default
				if ( ! isset( $child['hasdefault'] ) || ! ( $child['default'] ?? false ) ) continue;

				$retainChildren = isset( $child['retainchildren'] );

				if ( isset( $child['elements'] ) && count( $child['elements'] ) > 0 )
				{
					if ( isset( $node['elements'] ) )
					{
						// $node['elements'] = array_merge( $node['elements'], $child['elements'] );
						foreach ( $child['elements'] as $elementKey => $element )
						{
							if ( ! $this->entry_is_unique( $node['elements'], $element, $element['entity'] ) ) continue;
							$node['elements'][] = $element;
						}
					}
					else
					{
						$node['elements'] = $child['elements'];
					}

					if ( ! $retainChildren )
					{
						if ( isset( $node['children'][ $child['label'] ] ) )
						{
							unset( $node['children'][ $child['label'] ] );
							unset( $node['children'] );
						}
					}
				}
				else
				{
					$retainChildren = true;
				}

				if ( $retainChildren )
				{
					$node['children'] = $child['children'];
					// Child may have been set before
					unset( $child );
					foreach ( $node['children'] as $childKey => &$child )
					{
						$child['parent'] = $node['label'];
					}
				}

			}
		}
	}

	/**
	 * Prune the unused nodes.  These do not have a 'used' element.
	 *
	 * @param array $roles
	 * @return void
	 */
	private function pruneNodes( &$roles )
	{
		$this->log()->info( "Prune" );
		foreach ( $roles as $roleKey => &$role )
		{
			if ( isset( $role['locators'] ) ) unset( $role['locators'] );
			if ( isset( $role['paths'] ) ) unset( $role['paths'] );

			foreach ( $role['hierarchy'] as $headingKey => &$heading )
			{
				// If not used, prune
				if ( ! isset( $heading['used'] ) )
				{
					// $this->log()->info( "Prune $headingKey" );
					unset( $role['hierarchy'][ $headingKey ] );
					continue;
				}

				if ( ! isset( $role['hierarchy'][ $headingKey ]['taxonomy_element'] ) )
				{
					$taxonomy = $this->getTaxonomy()->getTaxonomyForXSD( $heading['label'] );
					$role['hierarchy'][ $headingKey ]['taxonomy_element'] = $taxonomy->getElementById( $heading['label'] );
				}

				$me = $this;
				$pruneNodes = function( &$nodes ) use( &$pruneNodes, &$role, $me )
				{
					foreach ( $nodes as $nodeKey => &$node )
					{
						// If not used, prune
						if ( ! isset( $node['used'] ) )
						{
							unset( $nodes[ $nodeKey ] );
							continue;
						}
						else if ( isset( $node['children'] ) )
						{
							$pruneNodes( $node['children'] );
						}

						if ( ! isset( $node['taxonomy_element'] ) )
						{
							$taxonomy = $me->getTaxonomy()->getTaxonomyForXSD( $node['label'] );
							$node['taxonomy_element'] = $taxonomy->getElementById( $node['label'] );
						}
					}
				};

				$pruneNodes( $heading['children'] );
				unset( $me );
			}

			if ( count( $role['hierarchy'] ) === 0 )
			{
				unset( $roles[ $roleKey ] );
			}
		}
	}

	/**
	 * Process the dimemsion member with key $memberKey
	 *
	 * @param array  $dimNode		A node representing the dimension to be added
	 * @param string $memberKey		The label of the member to be added to the dimension
	 * @param string $text			The description of the dimension
	 * @param string $dimMember
	 * @param array  $node
	 * @param array  $dim
	 * @param array  $activeDimensions
	 * @param string $path
	 */
	private function processDimensionMembers( $dimNode, $memberKey, $text, $dimMember, $node, $dim, $activeDimensions, $path = "" )
	{
		if ( isset( $memNode ) ) unset( $memNode );

		// In the case where more than one dimension is assigned to the node (rather than using 'common' nodes) then the effect of assigning the
		// node as a child of $memNode is to retain a copy of the any subsequent dimensions that have been assigned to the node in child of the $memNode.
		// This causes subsequent dimensions to be used multiple times.
		// To get around this, the dimensions of the node are copied and then deleted before the node is assigned.
		$nodeDimensions = isset( $node['dimensions'] ) ? $node['dimensions'] : array();
		unset( $nodeDimensions[ $dimNode['label'] ] );

		unset( $node['dimensions'] );

		$memNode = array(
			'nodeclass' => 'member',
			'label' => $memberKey,
			'text' => $text,
			'dimensions' => $nodeDimensions,
			'parent' => $dimNode['label'],
			'default' => $dimMember['default'],
			'taxonomy_element' => $dimMember['taxonomy_element'],
		);

		if ( isset( $node['preferredLabel'] ) ) $memNode['preferredLabel'] = $node['preferredLabel'];

		unset( $dimMember['taxonomy_element'] );

		if ( isset( $node['elements'] ) )
		{
			// If the current node is a primary item, only copy the elements that are dimensional
			if ( $node['nodeclass'] === 'primaryitem' )
			{
				$memNode['elements'] = array_filter( $node['elements'], function( $element ) { return ! isset( $element['nodim'] ) || ! $element['nodim']; } );
			}
			else
			{
				$memNode['elements'] = $node['elements'];
			}
		}

		$children = isset( $node['children'] )
			? $node['children']
			: null;

		if ( $children !== null )
		{
			foreach ( $children as $nodeKey => &$node )
			{
				$node['parent'] = $memberKey;
			}

			$memNode['children'] = $children;
		}

		$dimNode['children'][ $memberKey ] =& $memNode;

		$children = $this->processDimensionGroups(
			$dimNode['children'],
			array_merge( $activeDimensions, array( $dim['label'] => $dimMember ) ),
			$path
		);

		if ( ! isset( $children[ $memberKey ] ) )
		{
			unset( $dimNode['children'][ $memberKey ] );
		}

		foreach ( $children as $childKey => $child )
		{
			if ( isset( $child['processed'] ) && $child['processed'] ) continue;
			$dimNode['children'][ $childKey ] = $child;
		}

		if ( isset( $memNode['dimensions'] ) ) unset( $memNode['dimensions'] );
		$memNode['processed'] = true;

		return $dimNode;
	}

	/**
	 * Provides handling for any dimensions found in a node. The existence of dimensions associated with a node
	 * will be used to create a new node for the first of the dimensions.
	 *
	 * @param array $node				A standard node array with 'label', 'text' and 'children' elements
	 * @param array $newNode			The new node to be created to represent a dimension
	 * @param array $activeDimensions	A list of the dimensions accrued from parent nodes
	 * @param string $path				The current path
	 * @return boolean True if the dimension is handled
	 */
	private function handleDimensions( &$node, &$newNode, $activeDimensions = array(), $path = "" )
	{
		// Are there any dimensions to process?
		if ( ! isset( $node['dimensions'] ) || count( $node['dimensions'] ) === 0 ) return false;

		// If there are child nodes then the dimensions apply to child nodes.
		// They ned to be processed in sequence with one selected and used to
		// create a new node. The rest of the dimensions are passed to the
		// new node to potentially repeat the process until no dimensions remain.
		// Function will return the entries that are not consumed.

		// Get the first dimension and remove it from the collection so it is
		// not processed again in recursive calls to processDimensionGroups
		$dim = reset( $node['dimensions'] );

		/*
		 $dimNode['dimensions']
			[ $dimensionKey ]= array
				'label'
				'text'
				'targetRole'
				['default']
					'label'
					'text'
				['members']
					[ $memberKey ] = array
						'label'
						'text'
		*/

		// Create a new node for the dimension.  It will be added as a child of the node.
		if ( isset( $dimNode ) ) unset( $dimNode );

		/**
		 * Determine if this dimension is used by any element
		 * @param array $node The node containing elements to check
		 * @param string $dimensionKey The dimension
		 * @param string $memberKey (Optional) The dimension member to check
		 * @return bool
		 */
		$hasElementWithDimensionMember = function( $node, $dimensionKey, $memberKey = null ) use( &$hasElementWithDimensionMember )
		{
			// There is a choice here:
			// 1) If there are no elements on a primary item node, should the function always return true?; or
			// 2) Should the function look at the elements of any children?

			if ( isset( $node['elements'] ) )
			{
				$dimKey = $dimensionKey; // strpos( $dimensionKey, "#" ) === false ? $dimensionKey : parse_url( $dimensionKey, PHP_URL_FRAGMENT );
				$memKey = $memberKey; // $memberKey === null ? null : (strpos( $memberKey, "#" ) === false ? $memberKey : parse_url( $memberKey, PHP_URL_FRAGMENT ) );

				if ( count( array_filter( $node['elements'], function( $element ) use( $dimKey, $memKey ) {
					return isset( $element['validCombination'] ) &&
						   isset( $element['validCombination'][ $dimKey ] ) &&
						   ( $memKey === null || $element['validCombination'][ $dimKey ] === $memKey );
				} ) ) > 0 ) return true;
			}

			if ( ! isset( $node['children'] ) ) return false;

			foreach ( $node['children'] as $nodeKey => $node )
			{
				if ( $hasElementWithDimensionMember( $node, $dimensionKey, $memberKey ) ) return true;
			}

			return false;
		};

		$result = $hasElementWithDimensionMember( $node, $dim['label'] );
		if ( ! $result ) return false;

		$dimNode = array(
			'nodeclass' => 'dimension',
			'label' => $dim['label'],
			'text' => $dim['text'],
			'children' => array(), // All dimensions have at least one one child (the members)
			'parent' => $node['label'],
			'hasdefault' => false,
			'taxonomy_element' => $dim['taxonomy_element'],
		);

		if ( isset( $node['preferredLabel'] ) ) $dimNode['preferredLabel'] = $node['preferredLabel'];

		// Begin with a default if there is one
		if ( isset( $dim['default'] ) )
		{
			$result = $hasElementWithDimensionMember( $node, $dim['label'], $dim['default']['label'] );
			// $result = true;

			if ( $result )
			{
				$dimNode['hasdefault'] = true;

				$dimNode = $this->processDimensionMembers(
					$dimNode,
					$dim['default']['label'],
					$dim['default']['text'],
					array(
						'member' => $dim['default']['label'],
						'default' => true,
						'taxonomy_element' => $dim['default']['taxonomy_element'],
					),
					$node,
					$dim,
					$activeDimensions,
					"$path/{$dimNode['label']}"
				);
			}
		}

		if ( isset( $dim['members'] ) && count( $dim['members'] ) > 0 )
		{
			foreach ( $dim['members'] as $memberKey => $member )
			{
				$result = $hasElementWithDimensionMember( $node, $dim['label'], $memberKey );
				// $result = true;

				if ( ! $result ) continue;

				$dimNode = $this->processDimensionMembers(
					$dimNode,
					$memberKey,
					$member['text'],
					array(
						'member' => $memberKey,
						'default' => false,
						'taxonomy_element' => $member['taxonomy_element'],
					),
					$node,
					$dim,
					$activeDimensions,
					"$path/{$dimNode['label']}"
				);
			}
		}

		// Some of the elements in $node will have been allocated and some not.  The unallocated may be a 'total' figure.
		// This function aims to identify the unallocated items.  The challenge is that the elements may be allocated
		// across dimension members.  For example, suppose there are two primary items: SharesIssued and ShareHoldersEquity
		// where SharesIssued has a child item (though there could be many child items) call Other.
		// Each of these primary items will have zero or more elements assigned. Futher, suppose there are two members of a
		// dimenion of a relevant hypercube, say, ShareHolderComponents : CommonStockMember and PreferredStockMember.
		//
		// The variable $dimNode will hold a structure like:
		//
		// 	CommonStockMember
		//		SharesIssued
		//			Other
		//		ShareHoldersEquity
		// 	PreferredStockMember
		//		SharesIssued
		//			Other
		//		ShareHoldersEquity
		//
		// Where each of the primary items will have been allocated zero or more elements from $node.  The task is to
		// workout for each dimension member which elements have not been allocated so they can be allocated to that member.
		// In the example above, there may have been 6 elements assigned to SharesIssued in $node with 2 allocated to
		// CommonStockMember/SharesIssued and 2 to PreferredStockMember/SharesIssued.  This means there are 2 unallocated.
		// In this example, none have been allocated to Other.
		//
		$postProcessPrimaryItems = function( $outerNode, $path = "" ) use( &$postProcessPrimaryItems, &$dimNode )
		{
			if ( ! isset( $node['children'] ) ) return;

			foreach ( $outerNode['children'] as $nodeKey => $node )
			{
				if ( isset( $node['elements'] ) )
				{
					$usedElements = array();

					// See which of the elements have been used
					foreach ( $dimNode['children'] as $memberKey => $memberNode )
					{
						// Only interested in the $node key children of $childNode
						if ( ! isset( $memberNode['children'][ $nodeKey ] ) ) continue;
						if ( ! isset( $memberNode['children'][ $nodeKey ]['elements'] ) ) continue;
						$usedElements += $memberNode['children'][ $nodeKey ]['elements'];
					}

					// Should have all the used elements.  How do they compare with the unallocated ones?
					if ( count( $usedElements ) === count( $node['elements'] ) ) continue;
					if ( count( $usedElements ) > count( $node['elements'] ) )
					{
						// Oops something has gone wrong!
						continue;
					}

					$unallocated = array_diff_key( $node['elements'], $usedElements );
				}

				if ( ! empty( $path ) ) $path .= "/";
				$postProcessPrimaryItems( $node, $path . $nodeKey );
			}
		};

		if ( ( isset( $dimNode['children'] ) && count( $dimNode['children'] ) > 0 ) ||
			 ( isset( $dimNode['elements'] ) && count( $dimNode['elements'] ) > 0 ) )
		{
			$dimNode['processed'] = true;
			if ( isset( $dimNode['elements'] ) && $dimNode['elements'] )
			{
				$elements = $dimNode['elements'];
				unset( $dimNode['elements'] );
				$newNode['elements'] = $elements;
			}
			$newNode['children'][ $dim['label'] ] = $dimNode;
		}

		if ( ! isset( $newNode['children'] ) || count( $newNode['children'] ) === 0 ) $newNode = null;

		return true;
	}

	/**
	 * The purpose of this function is to add repeating groups to the
	 * presentation node tree to accommodate dimensions.
	 *
	 * @param array $nodes						An array of nodes with a 'children' element
	 * @param array $parent						The parent to which child nodes with elements are to be added
	 * @param array $activeDimensions			A list of the dimensions accrued from parent nodes.  This list represents those dimensions
	 * 											which have not yet been added to the node hierarchy from the perspective of $parent
	 * @param array $previousDimensionMembers	A list of the dimensions that have been added as nodes to an ancestor node
	 * 											These will be used for element validation only
	 * @param string $path						The current path
	 * @return void
	 *
	 * If a node has dimensions then they need to be added defined by the 'validCombinations'
	 * collection in the node elements.  How they are added depends on the type of the node
	 * to which the dimensions have been assigned.
	 *
	 * There are broadly three scenarios:
	 *
	 * 1) The dimensions are of a primary item node
	 * 2) The dimensions are of a simple node which has primary item nodes
	 * 3) The dimensions are of a simple node which has simple nodes
	 *
	 * There are then variations on each theme.  For example the primary item node may have
	 * their own children.  The children of a node with dimensions might have child nodes
	 * with additional dimensions.
	 *
	 * Almost certainly the first node will be a simple node with dimensions.  The end goal
	 * is to create a node that has the following structure.  Key:
	 * <> - Dimensions (x,y;default)
	 * [] - Child nodes
	 * () - Elements
	 *
	 *	Simple
	 * 		<A: a,b,c;d>
	 * 		<B: h,i,j;k>
	 * 		<C: x,y,z>
	 *		[One: (S) ]
	 *			(1: )
	 *  	[Two: (P) ]
	 *			(1: A,a;B,h;C,x)
	 *			(2: A,a;C,z)
	 *  	[Ten: (P) ]
	 *			(1: A,a;B,h;C,x)
	 *			(2: A,a;C,y)
	 *			(3: )
	 *
	 * The process will process this structure as follows:
	 *
	 * Begin with the Simple node and because the node has dimensions workout how the element
	 * values of child nodes should be assigned to dimensions.  The simple node is copied to
	 * create a base for all dimensionalized (?) node.
	 *
	 * Node 'One' is copied directly to 'Simple'
	 * Node 'Two' is a primary item with elements so the valid combinations will be used to
	 * select the dimensions and members from which sub-nodes will be created in this way.
	 *
	 * The process will iterate over the elements of the node 'One'.  The valid combinations
	 * list of each element will be used to add dimension and member nodes to the Simple node
	 * working in the sort order of the dimensions of the Simple node.
	 *
	 * A node for each dimension/member will be added to to the Simple node (the relevant
	 * dimension/member already added to the Simple node).  The node 'One' will be copied to
	 * the final dimension member with the element.  Note that the dimensions/members and
	 * the node may already exist so the task may be to locate the existing nodes and update
	 * them.
	 *
	 * Variations: Node 'Two' has children; Node 'Ten' has additional dimensions.
	 *
	 * In detail about what happens when a primary item is being processed.
	 *
	 */
	public function processDimensionGroups2( &$nodes, &$parent = array(), $activeDimensions = array(), $previousDimensionMembers = array(), $path = "" )
	{
		// Record the current and ancestor nodes to aid navigation
		foreach ( $nodes as $nodeKey => &$node )
		{
			if ( isset( $newNode ) ) unset( $newNode );
			$newNode = $node; // A copy not a reference

			// Clean the new node of the stuff that's not needed in the result
			if ( isset( $newNode['dimensions'] ) )	unset( $newNode['dimensions'] );
			if ( isset( $newNode['children'] ) )	unset( $newNode['children'] );
			if ( isset( $newNode['parentNode'] ) )	unset( $newNode['parentNode'] );
			if ( isset( $newNode['elements'] ) )	unset( $newNode['elements'] );

			$nodeHasDimensions = isset( $node['dimensions'] ) && count( $node['dimensions'] ) > 0;
			$nodeHasElements = isset( $node['elements'] ) && count( $node['elements'] );
			$nodeHasChildren = isset( $node['children'] ) && count( $node['children'] );

			if ( ! $nodeHasChildren && ! $nodeHasElements ) continue;

			$nodeActiveDimensions = $activeDimensions + ( $nodeHasDimensions ? $node['dimensions'] : array() );

			switch ( $node['nodeclass'] )
			{
				case 'simple':

					// This is the simple case: copy the node to the current node then process any children
					// What happens if this is the child of a primary item?
					if ( $nodeHasElements )
					{
						$newNode['elements'] = $node['elements'];
					}
					$newNode['order'] = isset( $node['order'] ) ? $node['order'] : "0";
					$parent['children'][ $newNode['label'] ] =& $newNode;
					$path .= "/{$node['label']}";

					break;

				case 'primaryitem':

					// Check to see if there are elements to worry about
					if ( isset( $node['elements'] ) && count( $node['elements'] ) )
					{
						// If there are items in $previousDimensionMembers create a composite set of dimensions
						$totalDimensions = $previousDimensionMembers
							? array_keys( $nodeActiveDimensions ) + array_keys( $previousDimensionMembers )
							: array_keys( $nodeActiveDimensions );

						foreach ( $node['elements'] as $elementKey => $element )
						{
							// Now sort out the combinations/dimensions to use.  $activeDimensions will contain a list
							// of the dimensions that can be used by this node.  However the $node element(s) may contain
							// valid dimension/member combinations with additional dimensions because this list
							// contains dimensions that have been added previously so are not in the $activeDimensions
							// list.

							// Parent will always be the parent of $node but its necessary to track the
							// node that is the current one as dimensions ae processed.  Reset it for each $element.
							unset( $currentNode );
							$currentNode =& $parent;
							$currentPath = $path;

							// There should be as many valid combinations for the element as there are dimensions
							if ( count( $element['validCombination'] ) !== count( $totalDimensions ) )
							{
								unset( $node['elements'][ $elementKey ] );
								continue;
							}

							$commonDimensions = array_intersect_key( $element['validCombination'], array_flip( $totalDimensions ) );

							if ( count( $commonDimensions ) !== count( $element['validCombination'] ) )
							{
								$this->log()->info( "The count of dimensions for node {$node['label']} is not the sames the count of valid combinations" );
								continue;
							}

							// Now is the 'difficult' bit: adding the dimensions to the parent and then adding the $newNode and finally the element
							// TODO: Should the output be a primary item with a hierarchy of dimension members or dimension members with a terminal
							//		 primary item? The current implementation is the latter. It should be straight-forward to swap this around by
							//		 adding the $newNode first and instead add elements to the leaf member nodes.

							// Iterate over the dimensions in the order of the dimensions in $node
							$usedDimensionMembers = array();

							foreach ( $nodeActiveDimensions as $dimKey => $dimension )
							{
								// Look for the dimension in the $currentNode
								if ( ! isset( $currentNode['children'] ) )
									$currentNode['children'] = array();

								if ( ! isset( $currentNode['children'][ $dimKey ] ) )
								{
									$currentNode['children'][ $dimKey ] = array(
										"nodeclass" => "dimension",
										"label" => $dimension['label'],
										"text" => $dimension['text'],
										"hasdefault" => false,
										"order" => $dimension['order'],
									);
								}

								$currentPath .= "/$dimKey";
								$currentNode =& $currentNode['children'][ $dimKey ];

								$memberKey = $commonDimensions[ $dimKey ];

								// Look for the member in the $currentNode
								if ( ! isset( $currentNode['children'] ) )
									$currentNode['children'] = array();

								if ( ! isset( $currentNode['children'][ $memberKey ] ) )
								{
									// Is this member a default?
									$isDefaultMember = false;
									if ( isset( $dimension['default'] ) && $dimension['default']['label'] === $memberKey )
									{
										$currentNode['hasdefault'] = true;
										$isDefaultMember = true;
									}
									else
									{
										if ( ! isset( $dimension['members'][ $memberKey ] ) )
											continue;
									}

									$text = $isDefaultMember
										?  $dimension['default']['text']
										: ( isset( $dimension['members'][ $memberKey ] )
												? $dimension['members'][ $memberKey ]['text']
												: $memberKey
										  );

									// $dimension['default']['taxonomy_element']['id']
									$currentNode['children'][ $memberKey ] = array(
										"nodeclass" => "member",
										"label" => $memberKey,
										"text" => $text,
										"default" => $isDefaultMember,
										"order" => $isDefaultMember ? $dimension['default']['order'] : $dimension['members'][ $memberKey ]['order'],
									);
								}

								$currentPath .= "/$memberKey";
								$currentNode =& $currentNode['children'][ $memberKey ];

								// Record the used dimension/member
								if ( ! isset( $usedDimensionMembers[ $dimKey ] ) ) $usedDimensionMembers[ $dimKey ] = $memberKey;
							}

							if ( ! isset( $currentNode['children'] ) )
								$currentNode['children'] = array();

							if ( ! isset( $currentNode['children'][ $newNode['label'] ] ) )
							{
								$currentNode['children'][ $newNode['label'] ] = $newNode;
							}

							$currentPath .= "/{$newNode['label']}";
							$currentNode =& $currentNode['children'][ $newNode['label'] ];

							$currentNode['elements'][] = $element;

							unset( $node['elements'][ $elementKey ] );

							// By this point, an element of $node has been processed and potentially new output nodes created.
							// If $node has any children then those children need to be processed for each new dimension/member
							// combination added.

							// A check needs to be made because this combination may have been processed already (the same
							// valid combination can appear against more than one element such as when the element holds
							// information for different periods.

							if ( isset( $currentNode['children '] ) ) continue;

							// This step adds a complexity because the elements of the child nodes still need to be validated by
							// the dimensions and members represented by $activeDimensions. However, these have already been
							// added as nodes so they do not need to be added again.

							// The node may have children and the children may have additional dimensions
							if ( $nodeHasChildren )
							{
								// Process the children but start at $currentNode.
								$this->processDimensionGroups2( $node['children'], $currentNode, array(), $usedDimensionMembers, $currentPath );
							}
						}

						if ( count( $node['elements'] ) )
						{
							$newNode['elements'] = $node['elements'];
							$parent['children'][ $newNode['label'] ] =& $newNode;
							$path .= "/{$newNode['label']}";
						}
					}
					else
					{
						// Add the node directly to the
						$parent['children'][ $newNode['label'] ] =& $newNode;
						$path .= "/{$newNode['label']}";
					}

					break;

				default:

					$this->log()->info( "Default: {$node['label']}" );
					break;
			}

			// This block controls whether nodes or dimensions are
			// processed first (and it could do with a review)
			if ( ! $nodeHasChildren ) continue;

			$this->processDimensionGroups2( $node['children'], $newNode, $nodeActiveDimensions, $previousDimensionMembers, $path );

		}
	}

	/**
	 * The purpose of this function is to add repeating groups to the
	 * presentation node tree to accommodate dimensions.
	 *
	 * @param array $nodes				An array of nodes with a 'children' element
	 * @param array $activeDimensions	A list of the dimensions accrued from parent nodes
	 * @param string $path				The current path
	 * @return array
	 *
	 * For example, the tree at node 'Turnover' may have dimensions that are common
	 * to it and it's sub-nodes.  The Turnover node and the sub-nodes should be
	 * repeated for every combination of dimension members.
	 *
	 * If Turnover has two dimensions and both dimensions have two members then the
	 * Turnover tree will be repeated four times. A question is whether the tree is
	 * simply copied 4 times or whether the nodes are repeated for one of the
	 * dimensions and then again within that dimension for the second dimension.
	 * That is, does it have this structure:
	 *
	 * Dim 1 - Member 1
	 * 	Turover
	 * 		Sub-node
	 * Dim 1 - Member 2
	 * 	Turover
	 * 		Sub-node
	 * Dim 2 - Member 1
	 * 	Turover
	 * 		Sub-node
	 * Dim 2 - Member 2
	 * 	Turover
	 * 		Sub-node
	 *
	 * or this structure:
	 *
	 * Dim 1
	 * 	Member 1
	 * 		Turover
	 * 			Sub-node
	 * 	Member 2
	 * 		Turover
	 * 			Sub-node
	 * Dim 2
	 * 	Member 1
	 * 		Turover
	 * 			Sub-node
	 * 	Member 2
	 * 		Turover
	 * 			Sub-node
	 *
	 */
	public function processDimensionGroups( &$nodes, $activeDimensions = array(), $path = "" )
	{
		$newNodes = array();

		foreach ( $nodes as $nodeKey => $node )
		{
			if ( isset( $node['processed'] ) )
			{
				$newNodes[ $nodeKey ] = $node;
				continue;
			}

			if ( isset( $newNode ) ) unset( $newNode );
			$newNode = $node;

			if ( isset( $newNode['dimensions'] ) )	unset( $newNode['dimensions'] );
			if ( isset( $newNode['children'] ) )	unset( $newNode['children'] );
			if ( isset( $newNode['parentNode'] ) )	unset( $newNode['parentNode'] );

			$nodeIsDimensional = isset( $node['nodeclass'] ) && ( $node['nodeclass'] === 'dimension' || $node['nodeclass'] === 'member' );
			$nodeIsPrimaryItem = isset( $node['nodeclass'] ) && ( $node['nodeclass'] === 'primaryitem' );
			$nodeHasElements = isset( $newNode['elements'] ) && count( $newNode['elements'] );
			$nodeHasChildren = isset( $node['children'] ) && count( $node['children'] );
			$nodeHasDimensions = isset( $node['dimensions'] ) && count( $node['dimensions'] ) > 0;

			// This block controls whether nodes or dimensions are
			// processed first (and it could do with a review)
			if ( $nodeHasChildren )
			{
				// Begin the process of adding new nodes if dimensions exist.
				if ( $this->handleDimensions( $node, $newNode, $activeDimensions, "$path/{$node['label']}" ) )
				{
					// If the new node has children then add it to the collection
					// (if there are no children then there is no data to report below this node for the active dimensions)
					if ( $newNode === null ) continue;
				}
				else
				{
					// Getting here means the node has children but for some reason there are no dimensions to handle
					// If there are node dimensions that are unused then apply the unused to the child nodes.
					$newNode['children'] = $this->processDimensionGroups( $node['children'], $activeDimensions, "$path/{$node['label']}" );
				}

				// Nodes have been processed so any dimensions have been consumed
				$nodeHasDimensions = false;

				// Potential conditions here:
				$newNodeIsDimensional = ( $newNode['nodeclass'] ?? '' ) === 'dimension' || ( $newNode['nodeclass'] ?? '' ) === 'member';
				$newNodeIsPrimaryItem = ( $newNode['nodeclass'] ?? '' ) === 'primaryitem';
				$newNodeHasElements = isset( $newNode['elements'] ) && count( $newNode['elements'] );
				$newNodeHasChildren = isset( $newNode['children'] ) && count( $newNode['children'] );
				$newNodeHasPrimaryItemChildren = count( array_filter( $newNode['children'] ?? array(), function( $item ) { return ( $item['nodeclass'] ?? '' ) === 'primaryitem'; } ) );

				// Remove elements that have been used for non-primary item types
				if ( ! $newNodeHasPrimaryItemChildren && $newNodeHasElements && ! $newNodeIsPrimaryItem )
				{
					// BMS 2016-02-01 Commented this out.  It's causing problems with total/sub-total nodes.  Why is it here?
					$elements = array_filter( $newNode['elements'] ?? array(), function( $element ) { return isset( $element['used'] ) && $element['used']; } );
					if ( count( $elements ) === 0 )
						unset( $newNode['elements'] );
					else
						$newNode['elements'] = $elements;
				}

				if ( $newNodeHasChildren )
				{
					$newNodes[ $nodeKey ] = $newNode;
				}

				// If its a primary item or simple item continue along
				if ( ! $newNodeIsDimensional )
				{
					$elements = isset( $newNode['elements'] )
						? array_filter( $newNode['elements'], function( $element ) { return ! isset( $element['used'] ) || ! $element['used']; } )
						: array();

					if ( count( $elements ) === 0 )
						continue;
				}

				$newNodeHasElements = isset( $newNode['elements'] ) && count( $newNode['elements'] );

				// Any children have been processed.  If this is a dimension or member check there are elements to be concerned with.
				if ( ! $newNodeHasElements )
				{
					continue;
				}
			}

			// This is a leaf node. If there are no elements continue on.
			if ( ! $nodeHasElements )
			{
				// Don't think this should happen
				continue;
			}

			$effectiveDimensions = $activeDimensions;

			// Even though this is a leaf node, are there any dimensions to process?
			if ( ! $nodeHasChildren )
			{
				if ( $nodeHasDimensions )
				{
					if ( $this->handleDimensions( $node, $newNode, $activeDimensions, "$path/{$node['label']}" ) )
					{
						// If the new node has children then add it to the collection
						// (if there are no children then there is no data to report below this node for the active dimensions)
						if ( $newNode === null ) continue;
					}
					elseif ( isset( $node['children'] ) && count( $node['children'] ) > 0 )
					{
						$newNode['children'] = $this->processDimensionGroups( $node['children'], $activeDimensions, "$path/{$node['label']}" );
					}

					// Potential conditions here:
					$newNodeHasElements = isset( $newNode['elements'] ) && count( $newNode['elements'] );
					$newNodeHasChildren = isset( $newNode['children'] ) && count( $newNode['children'] );

					// Remove elements that have been used
					if ( $newNodeHasElements )
					{
						$elements = array_filter( $newNode['elements'],
							function( $element )
							{
								return ( isset( $element['used'] ) && $element['used'] ) || // Set by this function (see foreach below).  Not sure this is needed now.
									   ( isset( $element['unallocated'] ) && $element['unallocated'] ) || // Set by $postProcessMembers
									   ( isset( $element['nodim'] ) && $element['nodim'] ); // Set if the role has a hypercube but the element does not specify a dimension and there is no default dimension
							}
						);

						if ( count( $elements ) === 0 )
							unset( $newNode['elements'] );
						else
							$newNode['elements'] = $elements;
					}

					// There maybe [dimensional] children
					if ( $newNodeHasChildren )
					{
						// if ( isset( $newNode['elements'] ) ) unset( $newNode['elements'] );

						$newNodes[ $nodeKey ] = $newNode;
					}

					$newNodeHasElements = isset( $newNode['elements'] ) && count( $newNode['elements'] );

					// This is a leaf node. Dimensions have been processed and there are no elements continue on.
					if ( ! $newNodeHasElements )
					{
						continue;
					}
				}
			}
			else
			{
				if ( $nodeHasDimensions )
				{
					$effectiveDimensions = array_merge( $effectiveDimensions, $node['dimensions'] );
				}
			}

			/* ******************************************************************************************************************
			 * It's a leaf node and there are elements.
			 * ******************************************************************************************************************/

			// Do any of the elements apply to the dimensions being processed?
			// $effectiveDimensions is a dimension -> member value pair array of the
			// dimensions against which the context ref dimensions should be compared.
			$this->leafCount++;
			// if ( $this->leafCount % 1000 === 0 ) $this->log()->info( "" );

			// Process each node.  Only remove it if none of the tests succeed.
			foreach ( $newNode['elements'] as $elementKey => $element )
			{
				// If its used, it may be promoted so keep.
				if ( isset( $newNode['elements'][ $elementKey ]['used'] ) && $newNode['elements'][ $elementKey ]['used'] )
					continue;

				// If this was copied then mark this element as having been used
				$newNode['elements'][ $elementKey ]['used'] = true;

				// If there are no active dimensions and there are no dimensions
				// defined by the context ref then the element applies
				if ( ( ! isset( $element['context_dimensions'] ) || count( $element['context_dimensions'] ) === 0 ) && count( $effectiveDimensions ) === 0 ) continue;

				// If there are active dimensions but there are no dimensions
				// defined by the context ref then the element only applies if
				// all the active dimensions are defaults (the value of the
				// dimension -> member pair has 'default' === true)
				if ( ! isset( $element['context_dimensions'] ) || count( $element['context_dimensions'] ) === 0 )
				{
					// All the $effectiveDimensions should be default (dimension['default'] === true)
					if ( count( array_filter( $effectiveDimensions, function( $item ) { return isset( $item['default'] ) && $item['default']; } ) ) === count( $effectiveDimensions ) ) continue;
				}

				// If there are no active dimensions but there are dimensions
				// defined by the context ref then the element does not apply
				if ( isset( $element['context_dimensions'] ) && count( $element['context_dimensions'] ) > 0 && count( $effectiveDimensions ) === 0 )
				{
					$newNode['removed'][ $elementKey ] = $newNode['elements'][ $elementKey ];
					unset( $newNode['elements'][ $elementKey ] );
					continue;
				}

				// Now only considering the case where there are both active
				// dimensions and dimensions defined by the context ref.

				// There are now a number of conditions:
				// 1) The same dimensions are active and defined by the context
				// 2) There are active dimensions that are not defined by the context
				// 3) There are dimensions defined by the context that are not active
				// 4) There are dimensions defined by the context and they must be matched by an active dimension

				$notMatchedActive  = array_diff_key( $effectiveDimensions, isset( $element['context_dimensions'] ) ? $element['context_dimensions'] : array() );
				$notMatchedContext = array_diff_key( isset( $element['context_dimensions'] ) ? $element['context_dimensions'] : array(), $effectiveDimensions );
				unset( $usableDimensions );
				unset( $notMatchedActive2 );

				if ( count( $notMatchedContext ) > 0 )
				{
					// If there are context dimensions that do not match then the element does not apply.
					// TODO Check to see if any of the dimension members are really default members?
					$newNode['removed'][ $elementKey ] = $newNode['elements'][ $elementKey ];
					unset( $newNode['elements'][ $elementKey ] );
					continue;
				}

				$matchedActive = array_intersect_key( $effectiveDimensions, isset( $element['context_dimensions'] ) ? $element['context_dimensions'] : array() );
				if ( count( $matchedActive ) > 0 )
				{
					$dimensionsMatch = true; // Be positive

					// The dimensions and members have to match
					foreach ( $element['context_dimensions'] as $dimensionKey => &$contextDim )
					{
						if ( isset( $matchedActive[ $dimensionKey ] ) )
						{
							if ( isset( $matchedActive[ $dimensionKey ]['member'] ) )
							{
								if ( $matchedActive[ $dimensionKey ]['member'] === $contextDim['member'] )
								{
									$contextDim['matched'] = true;
									continue;
								}
							}
							else
							{
								// Here the $contextDim['member'] value could match any of the members of $matchedActive[ $dimensionKey ]['members']'
								if ( in_array( $contextDim['member'], array_keys( $matchedActive[ $dimensionKey ]['members'] ) ) )
								{
									$contextDim['matched'] = true;
									continue;
								}

								$dimensionsMatch = false;
								break;
							}
						}
						else
						{
							// This is a screw up because the array_intersect function has failed.
							exit;
						}

						$dimensionsMatch = false;
						break;
					}

					if ( ! $dimensionsMatch )
					{
						$newNode['removed'][ $elementKey ] = $newNode['elements'][ $elementKey ];
						unset( $newNode['elements'][ $elementKey ] );
						continue;
					}
				}

				// If there are unmatched active dimensions and no unmatched context
				// dimensions check to see if the unmatched active are default
				if ( count( $notMatchedActive ) > 0 && count( $notMatchedContext ) === 0 )
				{
					// The not matched active must be default.  Those that are can be removed.
					// The array can then proceed to be checked for equivalence with the context dimensions
					$notMatchedActive = array_filter( $notMatchedActive, function( $item ) { return ! isset( $item['default'] ) || ! $item['default']; } );
				}

				if ( count( $notMatchedActive ) === 0 && count( $notMatchedContext ) === 0 )
				{
					continue;
				}

				// Getting this far means the element is not valid for the required dimensions
				$newNode['removed'][ $elementKey ] = $newNode['elements'][ $elementKey ];
				unset( $newNode['elements'][ $elementKey ] );
			}

			// If there are no elements then the node does not need to be reported
			if ( count( $newNode['elements'] ) === 0 ) continue;

			$newNodes[ $nodeKey ] = $newNode;
		}

		return $newNodes;
	}

	/**
	 * Create HTML for one instance
	 * @return void
	 */
	public function toHtml()
	{
		if ( $this->hierarchies === null )
		{
			throw new Exception( "Hierarchies have not been generated.  Run preparePresentation() first." );
		}

		$this->log()->info( "Generate HTML" );

		$countYears = count( $this->years );
		$countEntities = count( $this->entities );
		$this->maxDepth++; // We're counting from zero
		$this->maxDepth++; // The sections are the zero'th items but do not figure in the depth calculation
		$totalColumns = $this->maxDepth + 0 + $countYears;

		// An array of alignments for the different elements
		// types such as string, number, date, boolean.
		// The type is taken from the element definition and
		// given an alignment by calling the 'valueAlignment'
		// function of the taxonomy class.  This information
		// is used to create CSS styles.
		$types = array();

		$dimensionInfos = array();
		$rows = array();
		// Process each of the roles to create report rows.
		// Each $rows entry is an array representing a <tr></tr> pair
		// and may contain sub-arrays representing the <td> elements
		foreach ( $this->hierarchies as $roleKey => $role )
		{
			if ( $this->taxonomy->excludeFromOutput( $roleKey ) ) continue;

			$roleHasItems = isset( $role['hierarchy'] ) && count( $role['hierarchy'] ) > 0;
			if ( ! $roleHasItems ) continue;

			$roleHypercubes = $this->getTaxonomy()->getPresentationRoleHypercubes( $roleKey );

			$roleHasDimensions = false;
			$roleHasDefaultDimensionMembers = false;
			$dimensionInfo = "";
			if ( $roleHypercubes )
			{
				$roleHasDimensions = array_reduce( $roleHypercubes, function( $carry, $hypercube ) { return $hypercube['dimensioncount'] + $carry; }, 0 );
			}

			if ( $roleHasDimensions )
			{
				$roleHasDefaultDimensionMembers = array_reduce( $roleHypercubes, function( $carry, $hypercube ) {
					return isset( $hypercube['hasdefaults'] ) ? $hypercube['hasdefaults'] + $carry : $carry;
				}, 0 );
			}

			if ( $roleHypercubes )
			{
				$countHypercubes = count( $roleHypercubes );
				$dimensionInfo = "(";

				$dimensionInfo .= $countHypercubes === 1 ? "1 hypercube" : "$countHypercubes hypercubes";

				if ( $roleHasDimensions )
				{
					$dimensionInfo .= " with $roleHasDimensions dimension" . ( $roleHasDimensions === 1 ? " " : "s " );
				}

				if ( $roleHasDimensions )
				{
					$dimensionInfo .= " - " . ($roleHasDefaultDimensionMembers ? "Has $roleHasDefaultDimensionMembers" : "No") . " default" . ( $roleHasDefaultDimensionMembers === 1 ? " " : "s " );
				}
				else
				{
					$dimensionInfo .= " No dimensions";
				}

				$dimensionInfo .= ")";

				$dimensionInfos[ $roleKey ] = $dimensionInfo;
			}

			unset( $roleHasHypercubes );

			$roleRows = array();
			if ( ( $rowCount = $this->processNode(
				$role['hierarchy'],
				$this->taxonomy,
				$types,
				$roleRows,
				$depth = 0,
				array(
					'maxDepth' => $this->maxDepth,
					'totalColumns' => $totalColumns,
					'countYears' => $countYears,
					'countEntities' => $countEntities,
				)
			) ) && $rowCount > 1 )
			{
				$companies = array();

				foreach ( $this->entities as $entity => $contexts )
					$companies[] = "<td class=\"value company\" colspan=\"{$countYears}\">{$entity}</td>";

				$rows[] = array(
					"<tr class=\"companies\" id=\"$roleKey-companies\">",
					array( "<td colspan=\"{$this->maxDepth}\">Section</td>" ),
					$companies,
					"</tr>",
				);

				$columns = array();

				foreach ( $this->entities as $entity => $contexts )
					foreach ( $this->years as $year => $contexts )
						$columns[] = "<td class=\"value heading\">{$year}</td>";

				$rows[] = array(
					"<tr class=\"years role\" id=\"$roleKey-years\">",
					array( "<td colspan=\"{$this->maxDepth}\">{$role['text']} $dimensionInfo</td>" ),
					$columns,
					"</tr>",
				);

				foreach ( $roleRows as $row ) $rows[] = $row;
			}
		}

		$column_count = ( $countYears * $countEntities ) + $this->maxDepth;
		$column_count_minus1 = $column_count -1;

		$content = array();
		end( $this->hierarchies );
		$lastKey = key( $this->hierarchies );
		foreach ( $this->hierarchies as $roleKey => $role )
		{
			$last = $roleKey === $lastKey ? " last" : "";
			$dimensionInfo = isset( $dimensionInfos[ $roleKey ] ) ? "<strong>{$dimensionInfos[ $roleKey ]}</strong>" : "";

			$content[] = array(
				"<tr id=\"$roleKey\" class=\"content-page$last\">",
				"<td/>",
				"<td colspan=\"{$column_count_minus1}\"><a href=\"#$roleKey-companies\">{$role['text']}</a> $dimensionInfo</td>",
				"</tr>",
			);
		}

		$heading = array( "<td class=\"filename\" colspan=\"{$this->maxDepth}\"></td>" );
		foreach ( $this->entities as $entityKey => $entity )
		{
			$document_name = $this->entityInstanceMap[ $entityKey ];
			$heading[] = "<td class=\"filename\" colspan=\"$countYears\">{$document_name}</td>";
		}

		$body = array(
			"<table class=\"reportTable\" cellspacing=\"0\" cellpadding=\"0\" >",
			array(
				"<thead>",
				"<meta charset=\"utf-8\"/>",
				array(
					"<tr>",
					array_fill( 0, $this->maxDepth -1, "<th class=\"text-columns\" />" ),
					array( "<th class=\"gap-column\"  />" ),
					array_fill( 0, $countYears * $countEntities, "<th class=\"value-columns\"  />" ),
					"</tr>",
				),
				"</thead>",
				"<tbody>",
				array(
					"<tr>",
					$heading,
					"</tr>",
				),
				$content,
				$rows,
				"</tbody>",
			),
			"</table>",
		);

		$style = array();
		foreach ( $types as $type => $alignment )
		{
			$style[] = "tr td." . str_replace( ":", "-", $type ) . " { text-align: $alignment; }";
		}

		// Build the head
		$head = array(
			"<style>",
			array(
				".reportTable tr.content-page.last td { padding-bottom: 30px; }",
				".reportTable td { border: 1px dotted #999999; }",
				".reportTable th.text-columns { min-width: 20px; }",
				".reportTable th.gap-column { width: 100%; }",
				".reportTable th.value-columns { min-width: 160px; }",
				".reportTable td.filename { text-align: center; }",
				"td { padding: 2px; vertical-align: top; min-width: 20px }",
				"tr.role{ border-top: 1px solid #999999; font-weight: bold; }",
				"tr.role td { border-top: 1px solid #999999; }",
				"tr td.value { border-left: 1px solid #999999; }",
				"tr td.value { text-align: left; }",
				"tr td.value.company, tr td.value.heading { text-align: center; }",
				"tr.tuple-gap > td.tuple { padding-top: 4px; border-top: 1px solid gray }",
				"tr.tuple-gap > td.description.tuple { padding-top: 4px; border-top: 1px solid gray }",
			),
			$style,
			"</style>",
		);

		$html = array(
			"<html>",
			array(
				"<head>",
				$head,
				"</head>",
			),
			array(
				"<body>",
				$body,
				"</body>",
			),
			"</html>",
		);

		// $this->log()->info( "Flatten: {$this->elapsedTime()}" );
		$x = $this->flatten( $html );
		// $this->log()->info( "Write: {$this->elapsedTime()}" );
		return join( "\n", $x );
	}

	/**
	 * Create JSON for one instance
	 * @return void
	 */
	public function toJson()
	{
		if ( $this->hierarchies === null )
			throw new Exception( "Hierarchies have not been generated.  Run preparePresentation() first." );

		$roles =& $this->taxonomy->getPresentationRoleRefs();

		foreach ( $this->hierarchies as $roleKey => &$role )
		{

		}
	}

	/**
	 * This is the work horse function used by toHtml() to generate the HTML for a node.
	 * The function preparePresentation added elements ($node['element']) (the things with actual values)
	 * to the presentation hierarchy.
	 * @param array					$nodes			An array of nodes with a 'children' element and an 'elements' array when data is to be presented
	 * @param XBRL					$taxonomy		An instance of the taxonomy underlying this report
	 * @param array					$types
	 * @param array					$rows
	 * @param int					$depth
	 * @param array					$parameters (maxDepth (int), totalColumns (int), countYears (int), countEntities (int), paths (array) )
	 * @return void
	 */
	private function processNode( $nodes, &$taxonomy, &$types, &$rows, $depth, $parameters = array() )
	{
		if ( ! is_array( $rows ) ) return;

		$countYears = $parameters['countYears'];
		$countEntities = $parameters['countEntities'];
		$this->maxDepth = $parameters['maxDepth'];

		uasort( $nodes, function( $a, $b ) {
			$ordera = isset( $a['order'] ) ? $a['order'] : 0;
			$orderb = isset( $b['order'] ) ? $b['order'] : 0;
			return $ordera > $orderb ? 1 : ( $ordera == $orderb ? 0 : -1 );
		} );

		// Look for opening balances.  Hopefully this is better than using the taxonomy specific openingBalancesSupplied() function
		$openingBalances = array_filter( $nodes, function( $node ) { return isset( $node['preferredLabel'] ) && $node['preferredLabel'] === XBRL_Constants::$labelRolePeriodStartLabel; } );
		$closingBalances = array();

		if ( count( $openingBalances ) > 0 )
		{
			// Look for nodes having the same id but with no preferred label or a period end label.
			// These are the corresponding closing balance elements.
			// The node class can only be 'simple' or 'primaryItem'
			foreach ( $openingBalances as $nodeKey => $openingBalance )
			{
				$closingBalances += array_filter( $nodes, function( $node ) use( $openingBalance ) {
					if (( $node['nodeclass'] ?? '' ) != 'simple' && ( $node['nodeclass'] ?? '' ) != 'primaryitem' ) return false;
					if ( $node['taxonomy_element']['id'] !== $openingBalance['taxonomy_element']['id'] ) return false;
					if ( ( $node['preferredLabel'] ?? '' ) === XBRL_Constants::$labelRolePeriodStartLabel ) return false;
					return true;
				} );
			}

			// Make sure the list of opening balances is filtered to include only those for which there is a closing balance element
			$openingBalances = array_intersect_ukey( $openingBalances, $closingBalances, function( $a , $b ) use( $nodes ) {
				return strcmp( $nodes[ $a ]['taxonomy_element']['id'], $nodes[ $b ]['taxonomy_element']['id'] );
			} );

			// Finally mark each element to denote it should treated as an opening balance
			foreach ( $openingBalances as $nodeKey => $openingBalance )
			{
				$nodes[ $nodeKey ]['openingbalance'] = true;
			}
		}

		foreach ( $nodes as $nodeKey => $node )
		{
			// This what a node looks like
			// $node			 					 = array( 'label', 'parent', 'arcrole', 'order', 'priority', 'use', 'text', 'depth', 'used', 'elements', 'dimensions' );
			// $node['elements']					 = array( 'taxonomy_element', 'namespace', 'precision', 'contextRef', 'unitRef', 'value'
			// $node['elements']					 = array( 'taxonomy_element', 'namespace', 'tuple_elements' );
			// $node['elements']['taxonomy_element'] = array( 'id', 'name', 'type', 'substitutionGroup', 'abstract', 'nillable', 'periodType', 'tuple_elements', 'balance' );
			// $node['elements']['tuple_elements'] is an array of elements
			// $node['dimensions'][ $dimension ]	 = array( 'label', 'member', 'member_text', 'dimension_text' )

			if ( $taxonomy->excludeFromOutput( $node['label'], XBRL_Instance::getElementType( $node ) ) ) continue;

			if ( ! isset( $node['children'] ) && ! $this->validElements( $node ) ) continue;

			// Some nodes may be abstract and not necessary to be displayed. Let the taxonomy instance decide.
			if ( ! $taxonomy->displayNode( $node ) )
			{
				$depth--;
			}
			else
			{
				$text = $taxonomy->sanitizeText( $node['text'] ) . ( isset( $node['order'] ) ? " ({$node['order']})" : "" );

				if ( $this->debug )
				{
					if ( isset( $node['taxonomy_element']['balance'] ) )
					{
						$text .= " ({$node['taxonomy_element']['balance']})";
					}
				}

				// This indent columns
				$output_array = $depth > 0 ? array_fill( 0, $depth, "<td/>" ) : array();

				// The description
				$remaining = $this->maxDepth - $depth;
				// $x = isset( $node['children'] ) && count( $node['children'] ) > 0 ? (count( $node['children'] ) . " children") : "leaf";
				// $y = isset( $node['elements'] ) && $validElements( $node ) ? (count( $node['elements'] ) . " values") : "no values";
				// $rows .= "					<td colspan=\"{$remaining}\">{$node['text']} ($x/$y)</td>\n";
				$output_array[] = "<td colspan=\"{$remaining}\">%text</td>";

				//  The member description is good enough if the next child is a primary item
				if ( ( $node['nodeclass'] ?? '' ) === 'member' && isset( $node['children'] ) && count( $node['children'] ) == 1 )
				{
					$child = reset( $node['children'] );
					if ( ( $child['nodeclass'] ?? '' ) === 'primaryitem' )
					{
						// Promote the node
						$node = $child;
					}
				}

				// The values
				if ( XBRL::isTuple( $node['taxonomy_element'] ) )
				{
					for ( $iEntity = 0; $iEntity < $countEntities; $iEntity++ )
					{
						$output_array[] = "<td colspan=\"{$countYears}\" class=\"value tuple\" ></td>";
					}
				}
				else if ( ! isset( $node['elements'] ) )
				{
					// No values, just columns
					for ( $iEntity = 0; $iEntity < $countEntities; $iEntity++ )
					{
						$output_array[] = "<td colspan={$countYears} class=\"value blank\" />";
					}
				}
				else if ( count( $node['elements'] ) === 1 && $taxonomy->treatAsText( $node['taxonomy_element']['id'], XBRL_Instance::getElementType( reset( $node['elements'] ) ) ) )
				{
					// $this->log()->info( "{$node['label']} - {$node['taxonomy_namespace']}" );
					// $this->log()->info( $node );

					// Merge any items into one (should only be one)
					$debug = $this->debug;

					foreach ( $this->entities as $entityKey => $iEntity )
					{
						$entityElements = array_filter( $node['elements'], function( $element ) use( $entityKey ) { return $element['entity'] === $entityKey; } );
						$type = XBRL_Instance::getElementType( reset( $node['elements'] ) );

						$values = array_map(
							function( $element ) use( $debug, $entityKey, $taxonomy, $type ) {
								$line = $taxonomy->sanitizeText( $element['value'], $type );
								// if ( $debug ) $line .= " ({$element['contextRef']})";
								return $line;
							},
							$entityElements
						);

						$entityIndex = array_search( $entityKey, array_keys( $this->entities ) );
						$class = str_replace( ":", "-", $type ) . "_" . $entityIndex;

						if ( ! empty( $type ) && ! isset( $types[ $class ] ) )
						{
							/**
							 * @var XBRL_Instance $instance
							 */
							$instance = $this->instanceDocuments[ $this->entityInstanceMap[ $entityKey ] ];
							$types[ $class ] = $taxonomy->valueAlignment( $type, $instance );
						}

						$value = "<p>" . implode( "</p><p>", $values ) . "</p>";
						$output_array[] = "<td colspan=\"{$countYears}\" class=\"value $class text\" contextRef=\"\">{$value}</td>";
					}
				}
				else
				{
					/*
					// Create CSS types for the elements to be shown on this row
					foreach ( $node['elements'] as $key => $element )
					{
						$type = XBRL_Instance::getElementType( $element );
						if ( empty( $type ) ) continue;

						if ( isset( $types[ $type ] ) ) continue;
						$types[ $type ] = $taxonomy->valueAlignment( $type );
					}
					*/

					// For each entity
					foreach ( $this->entities as $entityKey => $entity )
					{
						// This index is used to create css class
						$entityIndex = array_search( $entityKey, array_keys( $this->entities ) );

						/**
						 * @var XBRL_Instance $instance
						 */
						$instance = $this->instanceDocuments[ $this->entityInstanceMap[ $entityKey ] ];

						// For each valid year
						foreach ( $this->years as $year => $entities )
						{
							$contexts = $entities[ $entityKey ];

							// Make sure the elements are sorted in context date order (if two elements have the same date the results are undefined)
							if ( ! isset( $node['elementsSorted'] ) )
							{
								uasort( $node['elements'], function( $a, $b ) use( &$instance ) {

									$contexta = $instance->getContext( $a['contextRef'] );
									$contextb = $instance->getContext( $b['contextRef'] );

									$cmp = strcmp( $contexta['period']['endDate'], $contextb['period']['endDate'] );
									if ( $cmp !== 0 ) return $cmp;

									$diffa = isset( $contexta['period']['is_instant'] ) && $contexta['period']['is_instant']
										? 1
										: date_diff(
											DateTime::createFromFormat( 'Y-m-d', $contexta['period']['endDate'] ),
											DateTime::createFromFormat( 'Y-m-d', $contexta['period']['startDate'] )
										)->days;

									$diffb = isset( $contextb['period']['is_instant'] ) && $contexta['period']['is_instant']
										? 1
										: date_diff(
											DateTime::createFromFormat( 'Y-m-d', $contextb['period']['endDate'] ),
											DateTime::createFromFormat( 'Y-m-d', $contextb['period']['startDate'] )
										)->days;

									// The shorter one will be first
									if ($diffa == $diffb)
										return 0;

									return ($a < $b) ? -1 : 1;
								} );
								$node['elementsSorted'] = true;
							}

							// See if there is an overlap between contexts for this year and the elements
							$el = array_filter( $node['elements'], function( $el ) use( $contexts, $entityKey ) {

								// Check the element is for the current entity
								if ( $el['entity'] !== $entityKey ) return false;

								// $this->log()->info( isset( $el['contextRef'] ) ? "Has context ref\n" : "" );
								// If it's a tuple header then there will be no context
								return isset( $el['contextRef'] ) && isset( $contexts[ $el['contextRef'] ] );

							});

							if ( count( $el ) === 0 )
								$output_array[] = "<td class=\"value blank\" />";
							else
							{
								// This can happen when there are open and closing balances in the same year.
								$first = end( $el );  // Always choose the latest (they have been sorted by context date)

								// This can happen when there are open and closing balances in the same year.
								if ( isset( $node['preferredLabel'] ) &&
									 $node['preferredLabel'] === 'http://www.xbrl.org/2003/role/periodStartLabel' &&
									 ( ! $instance->getInstanceTaxonomy()->openingBalancesSupplied() || isset( $node['openingbalance'] ) )
								   )
								{
									// Look to see if there is a prior element
									$keys = array_keys( $node['elements'] );
									$newKey = array_search( key( $el ), $keys );
									$newKey--;
									// if ( $newKey >= 0 )
									{
										$first = isset( $keys[ $newKey ] )
											? $node['elements'][ $keys[ $newKey ] ]
											: null;
									}
								}

								if ( $first === null )
								{
									$output_array[] = "<td class=\"value blank\" />";
								}
								else
								{
									$type = (string) XBRL_Instance::getElementType( $first );
									$class = str_replace( ":", "-", $type ) . "_" . $entityIndex;

									if ( ! empty( $type ) && ! isset( $types[ $class ] ) )
									{
										$types[ $class ] = $taxonomy->valueAlignment( $type, $instance );
									}

									$value = $taxonomy->sanitizeText( $taxonomy->formattedValue( $first, $instance ) );
									$valuex = str_replace( chr(194) . chr(160), '', $value );
									$output_array[] = "<td class=\"value $class\" >$value</td>";
								}
							}
						}
					}
				}

				$rows[] = array(
					"<tr id=\"{$node['label']}\" >",
					array_map(
						function( $item, $index ) use( $depth, $text )
						{
							return $index === $depth ? str_replace( "%text", "$text", $item ) : $item;
						}, $output_array, array_keys( $output_array )
					),
					"</tr>",
				);

				if ( XBRL::isTuple( $node['taxonomy_element'] ) )
				{
					// Dump the tuples here if they exist.
					// The tuple members could just be free standing elements in the instance document
					// and represented as child nodes of the presentation node hierarchy.
					if ( ! isset( $node['elements'] ) || count( $node['elements'] ) === 0 )
					{
						$this->log()->info( "No tuple data available" );
						if ( isset( $node['children'] ) && count( $node['children'] ) > 0 )
						{
							$this->log()->info( "There are children, they will be used" );
						}
					}
					else
					{
						// Indent the tuple information
						$depth++;

						$firstElement = true;
						$trs = array();

						// Process instance elements for each entity.
						$firstEntity = true;
						foreach ( $this->entities as $entityKey => $entity )
						{
							// This index is used to create css class
							$entityIndex = array_search( $entityKey, array_keys( $this->entities ) );

							/**
							 * @var XBRL_Instance $instance
							 */
							$instance = $this->instanceDocuments[ $this->entityInstanceMap[ $entityKey ] ];

							foreach ( $node['elements'] as $elementKey => $element )
							{
								// Only process elements that are valid for this entity
								if ( $element['entity'] !== $entityKey ) continue;

								// if ( $element['taxonomy_element']['id'] === 'uk-gaap-ae_AccountingPolicy' )
								//	print_r( json_encode( $element ) );

								$remaining = $this->maxDepth - $depth;

								$firstTuple = true;
								$description = null;
								$values = array();
								$treatAsLabel = false;

								foreach ( $element['taxonomy_element']['tuple_elements'] as $taxonomyTupleKey => $taxonomyTuple )
								{
									if ( ! isset( $element['tuple_elements'][ $taxonomyTuple['name'] ] ) )
									{
										// $this->log()->info( "Cannot find tuple element with name '{$taxonomyTuple['name']}'\n";
										continue;
									}

									// Find each $taxonomyTuple['name'] in $element['tuple_elements']
									// This is more complicated that it should be.  Sometimes each element of a tuple is
									// self-contained: the decription is the text label and the value is the value.  However,
									// sometimes the tuples come as a pair of elements, the value of one element being the
									// description while the value of the other is the value of the pair.
									foreach ( $element['tuple_elements'][ $taxonomyTuple['name'] ] as $index => $tuple_element )
									{
										// Get the label for the tuple element. Begin by getting the taxonomy.
										/**
										 * @var XBRL $tuple_taxonomy
										 */
										$tuple_taxonomy = $taxonomy->getTaxonomyForNamespace( $taxonomyTuple['namespace'] );
										if ( ! $tuple_taxonomy )
										{
											$this->log()->info( "Cannot find taxonomy instance for namespace '{$taxonomyTuple['namespace']}'" );
											continue;
										}

										if ( ! isset( $instance->usedContexts[ $tuple_element['contextRef'] ] ) ) continue;

										$treatAsLabel = $tuple_taxonomy->treatAsLabel( $tuple_element['taxonomy_element']['id'] );
										$treatAsText = $tuple_taxonomy->treatAsText( $tuple_element['taxonomy_element']['id'], XBRL_Instance::getElementType( $tuple_element ) );
										$type = XBRL_Instance::getElementType( $tuple_element );

										if ( $treatAsLabel )
										{
											$description = $taxonomy->sanitizeText( trim( $tuple_element['value'] ), $type );
											continue;
										}
										else if ( $description === null )
										{
											$description = $tuple_taxonomy->getTaxonomyDescriptionForIdWithDefaults( $tuple_element['taxonomy_element']['id'] );
										}

										$values[  $instance->usedContexts[ $tuple_element['contextRef'] ]['year'] ] = array(
											'value'	  => $taxonomy->sanitizeText( ( $treatAsText ? trim( $tuple_element['value'] ) : $taxonomy->formattedValue( $tuple_element, $instance ) ), $type ),
											'element' => $tuple_element,
										);
									} // Next tuple element

									if ( $treatAsLabel ) continue;

									ksort( $values );

									$tdvalue = "";
									$colSpan = $countYears - ( count( $values ) - 1 );

									foreach ( $values as $key => $value )
									{
										$type = XBRL_Instance::getElementType( $value['element'] );
										$class = str_replace( ":", "-", $type ) . "_" . $entityIndex;

										if ( ! isset( $types[ $class ] ) )
										{
											$types[ $class ] = $taxonomy->valueAlignment( $type, $instance );
										}

										$tdvalue .= "<td colspan=\"{$colSpan}\" class=\"value $class\" >{$value['value']}</td>";
									}

									// If this is the first time a row has been created for this id, add a new array.
									// If not, update the existing td.  This will happen when there is more than one company being reported.
									$class = ! $firstElement && $firstTuple ? "class=\"tuple-gap\"" : "";

									// Create a list of indexes into the tr list
									$index = false;
									foreach ( $trs as $trKey => $tr )
									{
										if ( $tr['description'] !== $description || $tr['entity'] === $entityKey ) continue;
										$index = $trKey;
										break;
									}

									if ( $index !== false )
									{
										$trs[ $index ]['data']['td'][ $entityKey ] = $tdvalue;
										$trs[ $index ]['entity'] = $entityKey;
										$trs[ $index ]['description'] = $description;
									}
									else
									{
										$td = $depth > 0 ? array_fill( 0, $depth, "<td/>" ) : array();
										$td[] = "<td colspan=\"{$remaining}\" class=\"description tuple\">{$description}</td>";
										// Create a default entry for every entity in the report
										foreach ( $this->entities as $entityKey2 => $entity )
										{
											$td[ $entityKey2 ] = "<td colspan=\"{$countYears}\" class=\"value blank\" />";
										}
										$td[ $entityKey ] = $tdvalue;

										$trs[] = array(
											'entity' => $entityKey,
											'description' => $description,
											'data' => array(
												'tr_open' => "<tr $class>",
												'td' => $td,
												'tr_close' => "</tr>",
											),
										);
									}

									$description = null;
									$value = null;
									$values = null;

								} // Next taxonomy tuple

								$firstTuple = false;

							} // Next element

							$firstEntity = false;

						} // Next entity

						foreach ( $trs as $elementId => $tr )
						{
							// Check there are td elements for all the entities
							foreach ( $this->entities as $entityKey => $entity )
							{
								if ( isset( $tr['data']['td'][ $entityKey ] ) ) continue;
								// There is no key for this entity so add one
								$tr['data']['td'][ $entityKey ] = "<td colspan=\"{$countYears}\" class=\"value blank\" />";
							}
							$rows[] = $tr['data'];
						}

						$firstElement = false;

						$depth--;

						continue; // So any children are not processed
					}  // else
				}
				else if ( ! isset( $node['children'] ) ) continue;
			}

			$nodeRows = array();
			$subParameters = $parameters; // Got to make a copy or the parameters appear to be passed by reference
			$subParameters['paths'][] = $nodeKey;

			if ( ! $this->processNode(
				$node['children'],
				$taxonomy,
				$types,
				$nodeRows,
				$depth + 1,
				$subParameters
			) )
			{
				// There are no child rows so lose this node
				// BMS 2016-04-21
				// array_pop( $rows );
				if ( count( $rows )  ) array_pop( $rows );
				continue;
			}

			foreach ( $nodeRows as $row ) $rows[] = $row;
		}

		// If there is only one row then its only a header - there is no data.
		return count( $rows );
	}

	/**
	 * Called by ProcessNodes to assess whether there is something useful in the node
	 * @param array $node The node to assess
	 * @return boolean True if the element is valid for processing
	 */
	private function validElements( $node )
	{
		// The node must be an array
		if ( ! isset( $node ) ) return false;

		// The node may represent a tuple
		if ( XBRL::isTuple( $node['taxonomy_element'] ) ) return true;

		// There must be an element called 'elements'
		if ( ! isset( $node['elements'] ) ) return false;
		// The elements must have some members
		if ( count( $node['elements'] ) === 0 ) return false;

		foreach ( $node['elements'] as $elementKey => $element )
			if ( ! empty( $element['value'] ) /* || is_numeric( $element['value'] ) */ ) return true;
		return false;
	}

	/**
	 * Flatten an array of mixed values and arrays
	 *
	 * @param array $input			An array containing text and arrays to be flattened with indentation
	 * @param number $depth			The depth of the recursion.  Used to determine the number of tabs to add.
	 * @param number $startIndex	Value of the first index to use when adding
	 * 								strings to the flattened array to prevent keys
	 * 								overlapping so they can be joined.
	 * @return array A flat array of values.
	 */
	private function flatten( $input, $depth = 0, $startIndex = 0 )
	{
		$result = array();

		if ( ! is_array( $input ) ) return $result;

		foreach ( $input as $key => $item )
		{
			if ( is_array( $item ) )
			{
				$x = $this->flatten( $item, $depth + 1, $startIndex );
				$result = $result + $x;
				$startIndex += count( $x );
			}
			else
			{
				$result[ $startIndex ] = str_repeat( "\t", $depth ) . $item;
				$startIndex++;
			}
		}

		return $result;
	}

	/**
	 * Stores an ru structure representing the beginning of a timing session.
	 */
	private function startTiming()
	{
		if ( version_compare( PHP_VERSION, "7.0", "<" ) ) return;
		$this->rustart = getrusage();
	}

	/**
	 * Generate a progress value in milliseconds
	 * @param string $index An index such as 'utime' or 'stime'
	 * @return void|number
	 */
	private function elapsedTime( $index = 'utime')
	{
		if ( version_compare( PHP_VERSION, "7.0", "<" ) ) return;

		$rus = $this->rustart;
		$ru = getrusage();
		return ( $ru[ "ru_$index.tv_sec" ] * 1000 + intval( $ru[ "ru_$index.tv_usec" ] / 1000 ) ) - ( $rus ? $rus[ "ru_$index.tv_sec" ] * 1000 + intval( $rus[ "ru_$index.tv_usec" ] / 1000 ) : 0 );
	}

	/**
	 * Get the log instance
	 * @return XBRL_Log
	 */
	protected function log()
	{
		return XBRL_Log::getInstance();
	}
}

?>